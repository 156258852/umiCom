"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[717],{89705:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ icons_EllipsisOutlined; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(67294);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/EllipsisOutlined.js
// This icon file is generated automatically.
var EllipsisOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
/* harmony default export */ var asn_EllipsisOutlined = (EllipsisOutlined);

// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/components/AntdIcon.js + 2 modules
var AntdIcon = __webpack_require__(84089);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/EllipsisOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var EllipsisOutlined_EllipsisOutlined = function EllipsisOutlined(props, ref) {
  return /*#__PURE__*/react.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref,
    icon: asn_EllipsisOutlined
  }));
};

/**![ellipsis](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE3NiA1MTFhNTYgNTYgMCAxMDExMiAwIDU2IDU2IDAgMTAtMTEyIDB6bTI4MCAwYTU2IDU2IDAgMTAxMTIgMCA1NiA1NiAwIDEwLTExMiAwem0yODAgMGE1NiA1NiAwIDEwMTEyIDAgNTYgNTYgMCAxMC0xMTIgMHoiIC8+PC9zdmc+) */
var RefIcon = /*#__PURE__*/react.forwardRef(EllipsisOutlined_EllipsisOutlined);
if (false) {}
/* harmony default export */ var icons_EllipsisOutlined = (RefIcon);//# sourceURL=[module]
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk3MDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLHlCQUF5QixVQUFVLHlCQUF5QixrREFBa0QsaUJBQWlCLDBCQUEwQixxSUFBcUksR0FBRztBQUNqUyx5REFBZSxnQkFBZ0IsRUFBQzs7Ozs7QUNGMEI7QUFDMUQ7QUFDQTs7QUFFK0I7QUFDaUQ7QUFDbEM7QUFDOUMsSUFBSSxpQ0FBZ0I7QUFDcEIsc0JBQXNCLG1CQUFtQixDQUFDLHVCQUFRLEVBQUUsOEJBQVEsR0FBRztBQUMvRDtBQUNBLFVBQVUsb0JBQW1CO0FBQzdCLEdBQUc7QUFDSDs7QUFFQSxrQ0FBa0M7QUFDbEMsMkJBQTJCLGdCQUFnQixDQUFDLGlDQUFnQjtBQUM1RCxJQUFJLEtBQXFDLEVBQUUsRUFFMUM7QUFDRCwyREFBZSxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbnQtZGVzaWduL2ljb25zLXN2Zy9lcy9hc24vRWxsaXBzaXNPdXRsaW5lZC5qcz9jMGVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW50LWRlc2lnbi9pY29ucy9lcy9pY29ucy9FbGxpcHNpc091dGxpbmVkLmpzPzc4YWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBpY29uIGZpbGUgaXMgZ2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkuXG52YXIgRWxsaXBzaXNPdXRsaW5lZCA9IHsgXCJpY29uXCI6IHsgXCJ0YWdcIjogXCJzdmdcIiwgXCJhdHRyc1wiOiB7IFwidmlld0JveFwiOiBcIjY0IDY0IDg5NiA4OTZcIiwgXCJmb2N1c2FibGVcIjogXCJmYWxzZVwiIH0sIFwiY2hpbGRyZW5cIjogW3sgXCJ0YWdcIjogXCJwYXRoXCIsIFwiYXR0cnNcIjogeyBcImRcIjogXCJNMTc2IDUxMWE1NiA1NiAwIDEwMTEyIDAgNTYgNTYgMCAxMC0xMTIgMHptMjgwIDBhNTYgNTYgMCAxMDExMiAwIDU2IDU2IDAgMTAtMTEyIDB6bTI4MCAwYTU2IDU2IDAgMTAxMTIgMCA1NiA1NiAwIDEwLTExMiAwelwiIH0gfV0gfSwgXCJuYW1lXCI6IFwiZWxsaXBzaXNcIiwgXCJ0aGVtZVwiOiBcIm91dGxpbmVkXCIgfTtcbmV4cG9ydCBkZWZhdWx0IEVsbGlwc2lzT3V0bGluZWQ7XG4iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbi8vIEdFTkVSQVRFIEJZIC4vc2NyaXB0cy9nZW5lcmF0ZS50c1xuLy8gRE9OIE5PVCBFRElUIElUIE1BTlVBTExZXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBFbGxpcHNpc091dGxpbmVkU3ZnIGZyb20gXCJAYW50LWRlc2lnbi9pY29ucy1zdmcvZXMvYXNuL0VsbGlwc2lzT3V0bGluZWRcIjtcbmltcG9ydCBBbnRkSWNvbiBmcm9tIFwiLi4vY29tcG9uZW50cy9BbnRkSWNvblwiO1xudmFyIEVsbGlwc2lzT3V0bGluZWQgPSBmdW5jdGlvbiBFbGxpcHNpc091dGxpbmVkKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFudGRJY29uLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZixcbiAgICBpY29uOiBFbGxpcHNpc091dGxpbmVkU3ZnXG4gIH0pKTtcbn07XG5cbi8qKiFbZWxsaXBzaXNdKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU5UQWlJR2hsYVdkb2REMGlOVEFpSUdacGJHdzlJaU5qWVdOaFkyRWlJSFpwWlhkQ2IzZzlJalkwSURZMElEZzVOaUE0T1RZaUlHWnZZM1Z6WVdKc1pUMGlabUZzYzJVaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWkQwaVRURTNOaUExTVRGaE5UWWdOVFlnTUNBeE1ERXhNaUF3SURVMklEVTJJREFnTVRBdE1URXlJREI2YlRJNE1DQXdZVFUySURVMklEQWdNVEF4TVRJZ01DQTFOaUExTmlBd0lERXdMVEV4TWlBd2VtMHlPREFnTUdFMU5pQTFOaUF3SURFd01URXlJREFnTlRZZ05UWWdNQ0F4TUMweE1USWdNSG9pSUM4K1BDOXpkbWMrKSAqL1xudmFyIFJlZkljb24gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihFbGxpcHNpc091dGxpbmVkKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlZkljb24uZGlzcGxheU5hbWUgPSAnRWxsaXBzaXNPdXRsaW5lZCc7XG59XG5leHBvcnQgZGVmYXVsdCBSZWZJY29uOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
//# sourceURL=webpack-internal:///89705
`)},78957:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ space; }
});

// UNUSED EXPORTS: SpaceContext

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(67294);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Children/toArray.js
var toArray = __webpack_require__(50344);
;// CONCATENATED MODULE: ./node_modules/antd/es/_util/gapSize.js
function isPresetSize(size) {
  return ['small', 'middle', 'large'].includes(size);
}
function isValidGapNumber(size) {
  if (!size) {
    // The case of size = 0 is deliberately excluded here, because the default value of the gap attribute in CSS is 0, so if the user passes 0 in, we can directly ignore it.
    return false;
  }
  return typeof size === 'number' && !Number.isNaN(size);
}
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/antd/es/space/Compact.js
var Compact = __webpack_require__(4173);
;// CONCATENATED MODULE: ./node_modules/antd/es/space/context.js

const SpaceContext = /*#__PURE__*/react.createContext({
  latestIndex: 0
});
const SpaceContextProvider = SpaceContext.Provider;
;// CONCATENATED MODULE: ./node_modules/antd/es/space/Item.js
"use client";



const Item = _ref => {
  let {
    className,
    index,
    children,
    split,
    style
  } = _ref;
  const {
    latestIndex
  } = react.useContext(SpaceContext);
  if (children === null || children === undefined) {
    return null;
  }
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: className,
    style: style
  }, children), index < latestIndex && split && /*#__PURE__*/react.createElement("span", {
    className: \`\${className}-split\`
  }, split));
};
/* harmony default export */ var space_Item = (Item);
// EXTERNAL MODULE: ./node_modules/antd/es/space/style/index.js + 1 modules
var space_style = __webpack_require__(51916);
;// CONCATENATED MODULE: ./node_modules/antd/es/space/index.js
"use client";

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










const InternalSpace = /*#__PURE__*/react.forwardRef((props, ref) => {
  var _a, _b, _c;
  const {
    getPrefixCls,
    space,
    direction: directionConfig
  } = react.useContext(context/* ConfigContext */.E_);
  const {
      size = (_a = space === null || space === void 0 ? void 0 : space.size) !== null && _a !== void 0 ? _a : 'small',
      align,
      className,
      rootClassName,
      children,
      direction = 'horizontal',
      prefixCls: customizePrefixCls,
      split,
      style,
      wrap = false,
      classNames: customClassNames,
      styles
    } = props,
    otherProps = __rest(props, ["size", "align", "className", "rootClassName", "children", "direction", "prefixCls", "split", "style", "wrap", "classNames", "styles"]);
  const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
  const isPresetVerticalSize = isPresetSize(verticalSize);
  const isPresetHorizontalSize = isPresetSize(horizontalSize);
  const isValidVerticalSize = isValidGapNumber(verticalSize);
  const isValidHorizontalSize = isValidGapNumber(horizontalSize);
  const childNodes = (0,toArray/* default */.Z)(children, {
    keepEmpty: true
  });
  const mergedAlign = align === undefined && direction === 'horizontal' ? 'center' : align;
  const prefixCls = getPrefixCls('space', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = (0,space_style/* default */.Z)(prefixCls);
  const cls = classnames_default()(prefixCls, space === null || space === void 0 ? void 0 : space.className, hashId, \`\${prefixCls}-\${direction}\`, {
    [\`\${prefixCls}-rtl\`]: directionConfig === 'rtl',
    [\`\${prefixCls}-align-\${mergedAlign}\`]: mergedAlign,
    [\`\${prefixCls}-gap-row-\${verticalSize}\`]: isPresetVerticalSize,
    [\`\${prefixCls}-gap-col-\${horizontalSize}\`]: isPresetHorizontalSize
  }, className, rootClassName, cssVarCls);
  const itemClassName = classnames_default()(\`\${prefixCls}-item\`, (_b = customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.item) !== null && _b !== void 0 ? _b : (_c = space === null || space === void 0 ? void 0 : space.classNames) === null || _c === void 0 ? void 0 : _c.item);
  // Calculate latest one
  let latestIndex = 0;
  const nodes = childNodes.map((child, i) => {
    var _a, _b;
    if (child !== null && child !== undefined) {
      latestIndex = i;
    }
    const key = (child === null || child === void 0 ? void 0 : child.key) || \`\${itemClassName}-\${i}\`;
    return /*#__PURE__*/react.createElement(space_Item, {
      className: itemClassName,
      key: key,
      index: i,
      split: split,
      style: (_a = styles === null || styles === void 0 ? void 0 : styles.item) !== null && _a !== void 0 ? _a : (_b = space === null || space === void 0 ? void 0 : space.styles) === null || _b === void 0 ? void 0 : _b.item
    }, child);
  });
  const spaceContext = react.useMemo(() => ({
    latestIndex
  }), [latestIndex]);
  // =========================== Render ===========================
  if (childNodes.length === 0) {
    return null;
  }
  const gapStyle = {};
  if (wrap) {
    gapStyle.flexWrap = 'wrap';
  }
  if (!isPresetHorizontalSize && isValidHorizontalSize) {
    gapStyle.columnGap = horizontalSize;
  }
  if (!isPresetVerticalSize && isValidVerticalSize) {
    gapStyle.rowGap = verticalSize;
  }
  return wrapCSSVar(/*#__PURE__*/react.createElement("div", Object.assign({
    ref: ref,
    className: cls,
    style: Object.assign(Object.assign(Object.assign({}, gapStyle), space === null || space === void 0 ? void 0 : space.style), style)
  }, otherProps), /*#__PURE__*/react.createElement(SpaceContextProvider, {
    value: spaceContext
  }, nodes)));
});
const Space = InternalSpace;
Space.Compact = Compact/* default */.ZP;
if (false) {}
/* harmony default export */ var space = (Space);//# sourceURL=[module]
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg5NTcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7OztBQ1QwQjtBQUNuQixrQ0FBa0MsbUJBQW1CO0FBQzVEO0FBQ0EsQ0FBQztBQUNNLG1EOztBQ0pQOztBQUUrQjtBQUNVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CLENBQUMsY0FBYyxxQkFBcUIsbUJBQW1CO0FBQ2hHO0FBQ0E7QUFDQSxHQUFHLDBEQUEwRCxtQkFBbUI7QUFDaEYsa0JBQWtCLFVBQVU7QUFDNUIsR0FBRztBQUNIO0FBQ0EsK0NBQWUsSUFBSSxFOzs7O0FDekJuQjs7QUFFQSxhQUFhLFNBQUksSUFBSSxTQUFJO0FBQ3pCO0FBQ0E7QUFDQSw0SEFBNEgsY0FBYztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUMrQjtBQUNLO0FBQ2M7QUFDZ0I7QUFDZjtBQUNuQjtBQUNpQjtBQUN2QjtBQUNLO0FBQ1U7QUFDekMsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLGdCQUFnQixDQUFDLDZCQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQyxpQ0FBaUMsWUFBWTtBQUM3Qyw4QkFBOEIsZ0JBQWdCO0FBQzlDLGdDQUFnQyxnQkFBZ0I7QUFDaEQscUJBQXFCLDBCQUFPO0FBQzVCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQ0FBMEMsOEJBQVE7QUFDbEQsY0FBYyxvQkFBVSxzRkFBc0YsVUFBVSxHQUFHLFVBQVU7QUFDckksUUFBUSxVQUFVO0FBQ2xCLFFBQVEsVUFBVSxTQUFTLFlBQVk7QUFDdkMsUUFBUSxVQUFVLFdBQVcsYUFBYTtBQUMxQyxRQUFRLFVBQVUsV0FBVyxlQUFlO0FBQzVDLEdBQUc7QUFDSCx3QkFBd0Isb0JBQVUsSUFBSSxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGNBQWMsR0FBRyxFQUFFO0FBQ25HLHdCQUF3QixtQkFBbUIsQ0FBQyxVQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsR0FBRyw0QkFBNEIsbUJBQW1CLENBQUMsb0JBQW9CO0FBQ3ZFO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLGdCQUFnQix1QkFBTztBQUN2QixJQUFJLEtBQXFDLEVBQUUsRUFFMUM7QUFDRCwwQ0FBZSxLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvX3V0aWwvZ2FwU2l6ZS5qcz8yMzBhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL3NwYWNlL2NvbnRleHQuanM/MDhmNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9zcGFjZS9JdGVtLmpzPzVkNmEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvc3BhY2UvaW5kZXguanM/YzYwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNQcmVzZXRTaXplKHNpemUpIHtcbiAgcmV0dXJuIFsnc21hbGwnLCAnbWlkZGxlJywgJ2xhcmdlJ10uaW5jbHVkZXMoc2l6ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEdhcE51bWJlcihzaXplKSB7XG4gIGlmICghc2l6ZSkge1xuICAgIC8vIFRoZSBjYXNlIG9mIHNpemUgPSAwIGlzIGRlbGliZXJhdGVseSBleGNsdWRlZCBoZXJlLCBiZWNhdXNlIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBnYXAgYXR0cmlidXRlIGluIENTUyBpcyAwLCBzbyBpZiB0aGUgdXNlciBwYXNzZXMgMCBpbiwgd2UgY2FuIGRpcmVjdGx5IGlnbm9yZSBpdC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzTmFOKHNpemUpO1xufSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgU3BhY2VDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBsYXRlc3RJbmRleDogMFxufSk7XG5leHBvcnQgY29uc3QgU3BhY2VDb250ZXh0UHJvdmlkZXIgPSBTcGFjZUNvbnRleHQuUHJvdmlkZXI7IiwiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNwYWNlQ29udGV4dCB9IGZyb20gJy4vY29udGV4dCc7XG5jb25zdCBJdGVtID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY2xhc3NOYW1lLFxuICAgIGluZGV4LFxuICAgIGNoaWxkcmVuLFxuICAgIHNwbGl0LFxuICAgIHN0eWxlXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgbGF0ZXN0SW5kZXhcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoU3BhY2VDb250ZXh0KTtcbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IGNoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBzdHlsZTogc3R5bGVcbiAgfSwgY2hpbGRyZW4pLCBpbmRleCA8IGxhdGVzdEluZGV4ICYmIHNwbGl0ICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtjbGFzc05hbWV9LXNwbGl0YFxuICB9LCBzcGxpdCkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IEl0ZW07IiwiXCJ1c2UgY2xpZW50XCI7XG5cbnZhciBfX3Jlc3QgPSB0aGlzICYmIHRoaXMuX19yZXN0IHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB0b0FycmF5IGZyb20gXCJyYy11dGlsL2VzL0NoaWxkcmVuL3RvQXJyYXlcIjtcbmltcG9ydCB7IGlzUHJlc2V0U2l6ZSwgaXNWYWxpZEdhcE51bWJlciB9IGZyb20gJy4uL191dGlsL2dhcFNpemUnO1xuaW1wb3J0IHsgQ29uZmlnQ29udGV4dCB9IGZyb20gJy4uL2NvbmZpZy1wcm92aWRlcic7XG5pbXBvcnQgQ29tcGFjdCBmcm9tICcuL0NvbXBhY3QnO1xuaW1wb3J0IHsgU3BhY2VDb250ZXh0UHJvdmlkZXIgfSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IEl0ZW0gZnJvbSAnLi9JdGVtJztcbmltcG9ydCB1c2VTdHlsZSBmcm9tICcuL3N0eWxlJztcbmV4cG9ydCB7IFNwYWNlQ29udGV4dCB9IGZyb20gJy4vY29udGV4dCc7XG5jb25zdCBJbnRlcm5hbFNwYWNlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IHtcbiAgICBnZXRQcmVmaXhDbHMsXG4gICAgc3BhY2UsXG4gICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25Db25maWdcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoQ29uZmlnQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICAgIHNpemUgPSAoX2EgPSBzcGFjZSA9PT0gbnVsbCB8fCBzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BhY2Uuc2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3NtYWxsJyxcbiAgICAgIGFsaWduLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgcm9vdENsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZGlyZWN0aW9uID0gJ2hvcml6b250YWwnLFxuICAgICAgcHJlZml4Q2xzOiBjdXN0b21pemVQcmVmaXhDbHMsXG4gICAgICBzcGxpdCxcbiAgICAgIHN0eWxlLFxuICAgICAgd3JhcCA9IGZhbHNlLFxuICAgICAgY2xhc3NOYW1lczogY3VzdG9tQ2xhc3NOYW1lcyxcbiAgICAgIHN0eWxlc1xuICAgIH0gPSBwcm9wcyxcbiAgICBvdGhlclByb3BzID0gX19yZXN0KHByb3BzLCBbXCJzaXplXCIsIFwiYWxpZ25cIiwgXCJjbGFzc05hbWVcIiwgXCJyb290Q2xhc3NOYW1lXCIsIFwiY2hpbGRyZW5cIiwgXCJkaXJlY3Rpb25cIiwgXCJwcmVmaXhDbHNcIiwgXCJzcGxpdFwiLCBcInN0eWxlXCIsIFwid3JhcFwiLCBcImNsYXNzTmFtZXNcIiwgXCJzdHlsZXNcIl0pO1xuICBjb25zdCBbaG9yaXpvbnRhbFNpemUsIHZlcnRpY2FsU2l6ZV0gPSBBcnJheS5pc0FycmF5KHNpemUpID8gc2l6ZSA6IFtzaXplLCBzaXplXTtcbiAgY29uc3QgaXNQcmVzZXRWZXJ0aWNhbFNpemUgPSBpc1ByZXNldFNpemUodmVydGljYWxTaXplKTtcbiAgY29uc3QgaXNQcmVzZXRIb3Jpem9udGFsU2l6ZSA9IGlzUHJlc2V0U2l6ZShob3Jpem9udGFsU2l6ZSk7XG4gIGNvbnN0IGlzVmFsaWRWZXJ0aWNhbFNpemUgPSBpc1ZhbGlkR2FwTnVtYmVyKHZlcnRpY2FsU2l6ZSk7XG4gIGNvbnN0IGlzVmFsaWRIb3Jpem9udGFsU2l6ZSA9IGlzVmFsaWRHYXBOdW1iZXIoaG9yaXpvbnRhbFNpemUpO1xuICBjb25zdCBjaGlsZE5vZGVzID0gdG9BcnJheShjaGlsZHJlbiwge1xuICAgIGtlZXBFbXB0eTogdHJ1ZVxuICB9KTtcbiAgY29uc3QgbWVyZ2VkQWxpZ24gPSBhbGlnbiA9PT0gdW5kZWZpbmVkICYmIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2NlbnRlcicgOiBhbGlnbjtcbiAgY29uc3QgcHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKCdzcGFjZScsIGN1c3RvbWl6ZVByZWZpeENscyk7XG4gIGNvbnN0IFt3cmFwQ1NTVmFyLCBoYXNoSWQsIGNzc1ZhckNsc10gPSB1c2VTdHlsZShwcmVmaXhDbHMpO1xuICBjb25zdCBjbHMgPSBjbGFzc05hbWVzKHByZWZpeENscywgc3BhY2UgPT09IG51bGwgfHwgc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYWNlLmNsYXNzTmFtZSwgaGFzaElkLCBgJHtwcmVmaXhDbHN9LSR7ZGlyZWN0aW9ufWAsIHtcbiAgICBbYCR7cHJlZml4Q2xzfS1ydGxgXTogZGlyZWN0aW9uQ29uZmlnID09PSAncnRsJyxcbiAgICBbYCR7cHJlZml4Q2xzfS1hbGlnbi0ke21lcmdlZEFsaWdufWBdOiBtZXJnZWRBbGlnbixcbiAgICBbYCR7cHJlZml4Q2xzfS1nYXAtcm93LSR7dmVydGljYWxTaXplfWBdOiBpc1ByZXNldFZlcnRpY2FsU2l6ZSxcbiAgICBbYCR7cHJlZml4Q2xzfS1nYXAtY29sLSR7aG9yaXpvbnRhbFNpemV9YF06IGlzUHJlc2V0SG9yaXpvbnRhbFNpemVcbiAgfSwgY2xhc3NOYW1lLCByb290Q2xhc3NOYW1lLCBjc3NWYXJDbHMpO1xuICBjb25zdCBpdGVtQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyhgJHtwcmVmaXhDbHN9LWl0ZW1gLCAoX2IgPSBjdXN0b21DbGFzc05hbWVzID09PSBudWxsIHx8IGN1c3RvbUNsYXNzTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1c3RvbUNsYXNzTmFtZXMuaXRlbSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKF9jID0gc3BhY2UgPT09IG51bGwgfHwgc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYWNlLmNsYXNzTmFtZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pdGVtKTtcbiAgLy8gQ2FsY3VsYXRlIGxhdGVzdCBvbmVcbiAgbGV0IGxhdGVzdEluZGV4ID0gMDtcbiAgY29uc3Qgbm9kZXMgPSBjaGlsZE5vZGVzLm1hcCgoY2hpbGQsIGkpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChjaGlsZCAhPT0gbnVsbCAmJiBjaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsYXRlc3RJbmRleCA9IGk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQua2V5KSB8fCBgJHtpdGVtQ2xhc3NOYW1lfS0ke2l9YDtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSXRlbSwge1xuICAgICAgY2xhc3NOYW1lOiBpdGVtQ2xhc3NOYW1lLFxuICAgICAga2V5OiBrZXksXG4gICAgICBpbmRleDogaSxcbiAgICAgIHNwbGl0OiBzcGxpdCxcbiAgICAgIHN0eWxlOiAoX2EgPSBzdHlsZXMgPT09IG51bGwgfHwgc3R5bGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHlsZXMuaXRlbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gc3BhY2UgPT09IG51bGwgfHwgc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYWNlLnN0eWxlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLml0ZW1cbiAgICB9LCBjaGlsZCk7XG4gIH0pO1xuICBjb25zdCBzcGFjZUNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgbGF0ZXN0SW5kZXhcbiAgfSksIFtsYXRlc3RJbmRleF0pO1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT0gUmVuZGVyID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBpZiAoY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBnYXBTdHlsZSA9IHt9O1xuICBpZiAod3JhcCkge1xuICAgIGdhcFN0eWxlLmZsZXhXcmFwID0gJ3dyYXAnO1xuICB9XG4gIGlmICghaXNQcmVzZXRIb3Jpem9udGFsU2l6ZSAmJiBpc1ZhbGlkSG9yaXpvbnRhbFNpemUpIHtcbiAgICBnYXBTdHlsZS5jb2x1bW5HYXAgPSBob3Jpem9udGFsU2l6ZTtcbiAgfVxuICBpZiAoIWlzUHJlc2V0VmVydGljYWxTaXplICYmIGlzVmFsaWRWZXJ0aWNhbFNpemUpIHtcbiAgICBnYXBTdHlsZS5yb3dHYXAgPSB2ZXJ0aWNhbFNpemU7XG4gIH1cbiAgcmV0dXJuIHdyYXBDU1NWYXIoLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgcmVmOiByZWYsXG4gICAgY2xhc3NOYW1lOiBjbHMsXG4gICAgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnYXBTdHlsZSksIHNwYWNlID09PSBudWxsIHx8IHNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFjZS5zdHlsZSksIHN0eWxlKVxuICB9LCBvdGhlclByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3BhY2VDb250ZXh0UHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3BhY2VDb250ZXh0XG4gIH0sIG5vZGVzKSkpO1xufSk7XG5jb25zdCBTcGFjZSA9IEludGVybmFsU3BhY2U7XG5TcGFjZS5Db21wYWN0ID0gQ29tcGFjdDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFNwYWNlLmRpc3BsYXlOYW1lID0gJ1NwYWNlJztcbn1cbmV4cG9ydCBkZWZhdWx0IFNwYWNlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
//# sourceURL=webpack-internal:///78957
`)},72512:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  iz: function() { return /* reexport */ Divider; },
  ck: function() { return /* reexport */ es_MenuItem; },
  BW: function() { return /* reexport */ es_MenuItemGroup; },
  sN: function() { return /* reexport */ es_MenuItem; },
  Wd: function() { return /* reexport */ es_SubMenu; },
  ZP: function() { return /* binding */ rc_menu_es; },
  Xl: function() { return /* reexport */ useFullPath; }
});

// UNUSED EXPORTS: MenuItemGroup

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(4942);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__(1413);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules
var toConsumableArray = __webpack_require__(74902);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 1 modules
var slicedToArray = __webpack_require__(97685);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules
var objectWithoutProperties = __webpack_require__(91);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/rc-overflow/es/index.js + 6 modules
var es = __webpack_require__(39983);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useMergedState.js
var useMergedState = __webpack_require__(21770);
// EXTERNAL MODULE: ./node_modules/rc-util/es/isEqual.js
var isEqual = __webpack_require__(91881);
// EXTERNAL MODULE: ./node_modules/rc-util/es/warning.js
var warning = __webpack_require__(80334);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(67294);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(73935);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/context/IdContext.js

var IdContext = /*#__PURE__*/react.createContext(null);
function getMenuId(uuid, eventKey) {
  if (uuid === undefined) {
    return null;
  }
  return "".concat(uuid, "-").concat(eventKey);
}

/**
 * Get \`data-menu-id\`
 */
function useMenuId(eventKey) {
  var id = react.useContext(IdContext);
  return getMenuId(id, eventKey);
}
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useMemo.js
var useMemo = __webpack_require__(56982);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/context/MenuContext.js


var _excluded = ["children", "locked"];



var MenuContext = /*#__PURE__*/react.createContext(null);
function mergeProps(origin, target) {
  var clone = (0,objectSpread2/* default */.Z)({}, origin);
  Object.keys(target).forEach(function (key) {
    var value = target[key];
    if (value !== undefined) {
      clone[key] = value;
    }
  });
  return clone;
}
function InheritableContextProvider(_ref) {
  var children = _ref.children,
    locked = _ref.locked,
    restProps = (0,objectWithoutProperties/* default */.Z)(_ref, _excluded);
  var context = react.useContext(MenuContext);
  var inheritableContext = (0,useMemo/* default */.Z)(function () {
    return mergeProps(context, restProps);
  }, [context, restProps], function (prev, next) {
    return !locked && (prev[0] !== next[0] || !(0,isEqual/* default */.Z)(prev[1], next[1], true));
  });
  return /*#__PURE__*/react.createElement(MenuContext.Provider, {
    value: inheritableContext
  }, children);
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/context/PathContext.js


var EmptyList = [];

// ========================= Path Register =========================

var PathRegisterContext = /*#__PURE__*/react.createContext(null);
function useMeasure() {
  return react.useContext(PathRegisterContext);
}

// ========================= Path Tracker ==========================
var PathTrackerContext = /*#__PURE__*/react.createContext(EmptyList);
function useFullPath(eventKey) {
  var parentKeyPath = react.useContext(PathTrackerContext);
  return react.useMemo(function () {
    return eventKey !== undefined ? [].concat((0,toConsumableArray/* default */.Z)(parentKeyPath), [eventKey]) : parentKeyPath;
  }, [parentKeyPath, eventKey]);
}

// =========================== Path User ===========================

var PathUserContext = /*#__PURE__*/react.createContext(null);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/context/PrivateContext.js

var PrivateContext = /*#__PURE__*/react.createContext({});
/* harmony default export */ var context_PrivateContext = (PrivateContext);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Dom/isVisible.js
var isVisible = __webpack_require__(5110);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Dom/focus.js


function focusable(node) {
  var includePositive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if ((0,isVisible/* default */.Z)(node)) {
    var nodeName = node.nodeName.toLowerCase();
    var isFocusableElement =
    // Focusable element
    ['input', 'select', 'textarea', 'button'].includes(nodeName) ||
    // Editable element
    node.isContentEditable ||
    // Anchor with href element
    nodeName === 'a' && !!node.getAttribute('href');

    // Get tabIndex
    var tabIndexAttr = node.getAttribute('tabindex');
    var tabIndexNum = Number(tabIndexAttr);

    // Parse as number if validate
    var tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }

    // Block focusable if disabled
    if (isFocusableElement && node.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node) {
  var includePositive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var res = (0,toConsumableArray/* default */.Z)(node.querySelectorAll('*')).filter(function (child) {
    return focusable(child, includePositive);
  });
  if (focusable(node, includePositive)) {
    res.unshift(node);
  }
  return res;
}
var lastFocusElement = null;

/** @deprecated Do not use since this may failed when used in async */
function saveLastFocusNode() {
  lastFocusElement = document.activeElement;
}

/** @deprecated Do not use since this may failed when used in async */
function clearLastFocusNode() {
  lastFocusElement = null;
}

/** @deprecated Do not use since this may failed when used in async */
function backLastFocusNode() {
  if (lastFocusElement) {
    try {
      // \u5143\u7D20\u53EF\u80FD\u5DF2\u7ECF\u88AB\u79FB\u52A8\u4E86
      lastFocusElement.focus();

      /* eslint-disable no-empty */
    } catch (e) {
      // empty
    }
    /* eslint-enable no-empty */
  }
}
function limitTabRange(node, e) {
  if (e.keyCode === 9) {
    var tabNodeList = getFocusNodeList(node);
    var lastTabNode = tabNodeList[e.shiftKey ? 0 : tabNodeList.length - 1];
    var leavingTab = lastTabNode === document.activeElement || node === document.activeElement;
    if (leavingTab) {
      var target = tabNodeList[e.shiftKey ? tabNodeList.length - 1 : 0];
      target.focus();
      e.preventDefault();
    }
  }
}
// EXTERNAL MODULE: ./node_modules/rc-util/es/KeyCode.js
var KeyCode = __webpack_require__(15105);
// EXTERNAL MODULE: ./node_modules/rc-util/es/raf.js
var raf = __webpack_require__(75164);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useAccessibility.js






// destruct to reduce minify size
var LEFT = KeyCode/* default */.Z.LEFT,
  RIGHT = KeyCode/* default */.Z.RIGHT,
  UP = KeyCode/* default */.Z.UP,
  DOWN = KeyCode/* default */.Z.DOWN,
  ENTER = KeyCode/* default */.Z.ENTER,
  ESC = KeyCode/* default */.Z.ESC,
  HOME = KeyCode/* default */.Z.HOME,
  END = KeyCode/* default */.Z.END;
var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
function getOffset(mode, isRootLevel, isRtl, which) {
  var _offsets;
  var prev = 'prev';
  var next = 'next';
  var children = 'children';
  var parent = 'parent';

  // Inline enter is special that we use unique operation
  if (mode === 'inline' && which === ENTER) {
    return {
      inlineTrigger: true
    };
  }
  var inline = (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, UP, prev), DOWN, next);
  var horizontal = (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, LEFT, isRtl ? next : prev), RIGHT, isRtl ? prev : next), DOWN, children), ENTER, children);
  var vertical = (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, UP, prev), DOWN, next), ENTER, children), ESC, parent), LEFT, isRtl ? children : parent), RIGHT, isRtl ? parent : children);
  var offsets = {
    inline: inline,
    horizontal: horizontal,
    vertical: vertical,
    inlineSub: inline,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  var type = (_offsets = offsets["".concat(mode).concat(isRootLevel ? '' : 'Sub')]) === null || _offsets === void 0 ? void 0 : _offsets[which];
  switch (type) {
    case prev:
      return {
        offset: -1,
        sibling: true
      };
    case next:
      return {
        offset: 1,
        sibling: true
      };
    case parent:
      return {
        offset: -1,
        sibling: false
      };
    case children:
      return {
        offset: 1,
        sibling: false
      };
    default:
      return null;
  }
}
function findContainerUL(element) {
  var current = element;
  while (current) {
    if (current.getAttribute('data-menu-list')) {
      return current;
    }
    current = current.parentElement;
  }

  // Normally should not reach this line
  /* istanbul ignore next */
  return null;
}

/**
 * Find focused element within element set provided
 */
function getFocusElement(activeElement, elements) {
  var current = activeElement || document.activeElement;
  while (current) {
    if (elements.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}

/**
 * Get focusable elements from the element set under provided container
 */
function getFocusableElements(container, elements) {
  var list = getFocusNodeList(container, true);
  return list.filter(function (ele) {
    return elements.has(ele);
  });
}
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  // Key on the menu item will not get validate parent container
  if (!parentQueryContainer) {
    return null;
  }

  // List current level menu item elements
  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);

  // Find next focus index
  var count = sameLevelFocusableMenuElementList.length;
  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function (ele) {
    return focusMenuElement === ele;
  });
  if (offset < 0) {
    if (focusIndex === -1) {
      focusIndex = count - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset > 0) {
    focusIndex += 1;
  }
  focusIndex = (focusIndex + count) % count;

  // Focus menu item
  return sameLevelFocusableMenuElementList[focusIndex];
}
var refreshElements = function refreshElements(keys, id) {
  var elements = new Set();
  var key2element = new Map();
  var element2key = new Map();
  keys.forEach(function (key) {
    var element = document.querySelector("[data-menu-id='".concat(getMenuId(id, key), "']"));
    if (element) {
      elements.add(element);
      element2key.set(element, key);
      key2element.set(key, element);
    }
  });
  return {
    elements: elements,
    key2element: key2element,
    element2key: element2key
  };
};
function useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  var rafRef = react.useRef();
  var activeRef = react.useRef();
  activeRef.current = activeKey;
  var cleanRaf = function cleanRaf() {
    raf/* default */.Z.cancel(rafRef.current);
  };
  react.useEffect(function () {
    return function () {
      cleanRaf();
    };
  }, []);
  return function (e) {
    var which = e.which;
    if ([].concat(ArrowKeys, [ENTER, ESC, HOME, END]).includes(which)) {
      var keys = getKeys();
      var refreshedElements = refreshElements(keys, id);
      var _refreshedElements = refreshedElements,
        elements = _refreshedElements.elements,
        key2element = _refreshedElements.key2element,
        element2key = _refreshedElements.element2key;

      // First we should find current focused MenuItem/SubMenu element
      var activeElement = key2element.get(activeKey);
      var focusMenuElement = getFocusElement(activeElement, elements);
      var focusMenuKey = element2key.get(focusMenuElement);
      var offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);

      // Some mode do not have fully arrow operation like inline
      if (!offsetObj && which !== HOME && which !== END) {
        return;
      }

      // Arrow prevent default to avoid page scroll
      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
        e.preventDefault();
      }
      var tryFocus = function tryFocus(menuElement) {
        if (menuElement) {
          var focusTargetElement = menuElement;

          // Focus to link instead of menu item if possible
          var link = menuElement.querySelector('a');
          if (link !== null && link !== void 0 && link.getAttribute('href')) {
            focusTargetElement = link;
          }
          var targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);

          /**
           * Do not \`useEffect\` here since \`tryFocus\` may trigger async
           * which makes React sync update the \`activeKey\`
           * that force render before \`useRef\` set the next activeKey
           */
          cleanRaf();
          rafRef.current = (0,raf/* default */.Z)(function () {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      };
      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        // ========================== Sibling ==========================
        // Find walkable focus menu element container
        var parentQueryContainer;
        if (!focusMenuElement || mode === 'inline') {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL(focusMenuElement);
        }

        // Get next focus element
        var targetElement;
        var focusableElements = getFocusableElements(parentQueryContainer, elements);
        if (which === HOME) {
          targetElement = focusableElements[0];
        } else if (which === END) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
        }
        // Focus menu item
        tryFocus(targetElement);

        // ======================= InlineTrigger =======================
      } else if (offsetObj.inlineTrigger) {
        // Inline trigger no need switch to sub menu item
        triggerAccessibilityOpen(focusMenuKey);
        // =========================== Level ===========================
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = (0,raf/* default */.Z)(function () {
          // Async should resync elements
          refreshedElements = refreshElements(keys, id);
          var controlId = focusMenuElement.getAttribute('aria-controls');
          var subQueryContainer = document.getElementById(controlId);

          // Get sub focusable menu item
          var targetElement = getNextFocusElement(subQueryContainer, refreshedElements.elements);

          // Focus menu item
          tryFocus(targetElement);
        }, 5);
      } else if (offsetObj.offset < 0) {
        var keyPath = getKeyPath(focusMenuKey, true);
        var parentKey = keyPath[keyPath.length - 2];
        var parentMenuElement = key2element.get(parentKey);

        // Focus menu item
        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    }

    // Pass origin key down event
    originOnKeyDown === null || originOnKeyDown === void 0 || originOnKeyDown(e);
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/utils/timeUtil.js
function nextSlice(callback) {
  /* istanbul ignore next */
  Promise.resolve().then(callback);
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useKeyRecords.js






var PATH_SPLIT = '__RC_UTIL_PATH_SPLIT__';
var getPathStr = function getPathStr(keyPath) {
  return keyPath.join(PATH_SPLIT);
};
var getPathKeys = function getPathKeys(keyPathStr) {
  return keyPathStr.split(PATH_SPLIT);
};
var OVERFLOW_KEY = 'rc-menu-more';
function useKeyRecords() {
  var _React$useState = react.useState({}),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    internalForceUpdate = _React$useState2[1];
  var key2pathRef = (0,react.useRef)(new Map());
  var path2keyRef = (0,react.useRef)(new Map());
  var _React$useState3 = react.useState([]),
    _React$useState4 = (0,slicedToArray/* default */.Z)(_React$useState3, 2),
    overflowKeys = _React$useState4[0],
    setOverflowKeys = _React$useState4[1];
  var updateRef = (0,react.useRef)(0);
  var destroyRef = (0,react.useRef)(false);
  var forceUpdate = function forceUpdate() {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  };
  var registerPath = (0,react.useCallback)(function (key, keyPath) {
    // Warning for invalidate or duplicated \`key\`
    if (false) {}

    // Fill map
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.set(connectedPath, key);
    key2pathRef.current.set(key, connectedPath);
    updateRef.current += 1;
    var id = updateRef.current;
    nextSlice(function () {
      if (id === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  var unregisterPath = (0,react.useCallback)(function (key, keyPath) {
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key);
  }, []);
  var refreshOverflowKeys = (0,react.useCallback)(function (keys) {
    setOverflowKeys(keys);
  }, []);
  var getKeyPath = (0,react.useCallback)(function (eventKey, includeOverflow) {
    var fullPath = key2pathRef.current.get(eventKey) || '';
    var keys = getPathKeys(fullPath);
    if (includeOverflow && overflowKeys.includes(keys[0])) {
      keys.unshift(OVERFLOW_KEY);
    }
    return keys;
  }, [overflowKeys]);
  var isSubPathKey = (0,react.useCallback)(function (pathKeys, eventKey) {
    return pathKeys.filter(function (item) {
      return item !== undefined;
    }).some(function (pathKey) {
      var pathKeyList = getKeyPath(pathKey, true);
      return pathKeyList.includes(eventKey);
    });
  }, [getKeyPath]);
  var getKeys = function getKeys() {
    var keys = (0,toConsumableArray/* default */.Z)(key2pathRef.current.keys());
    if (overflowKeys.length) {
      keys.push(OVERFLOW_KEY);
    }
    return keys;
  };

  /**
   * Find current key related child path keys
   */
  var getSubPathKeys = (0,react.useCallback)(function (key) {
    var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
    var pathKeys = new Set();
    (0,toConsumableArray/* default */.Z)(path2keyRef.current.keys()).forEach(function (pathKey) {
      if (pathKey.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey));
      }
    });
    return pathKeys;
  }, []);
  react.useEffect(function () {
    return function () {
      destroyRef.current = true;
    };
  }, []);
  return {
    // Register
    registerPath: registerPath,
    unregisterPath: unregisterPath,
    refreshOverflowKeys: refreshOverflowKeys,
    // Util
    isSubPathKey: isSubPathKey,
    getKeyPath: getKeyPath,
    getKeys: getKeys,
    getSubPathKeys: getSubPathKeys
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useMemoCallback.js


/**
 * Cache callback function that always return same ref instead.
 * This is used for context optimization.
 */
function useMemoCallback(func) {
  var funRef = react.useRef(func);
  funRef.current = func;
  var callback = react.useCallback(function () {
    var _funRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
  }, []);
  return func ? callback : undefined;
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useUUID.js



var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
var internalId = 0;
function useUUID(id) {
  var _useMergedState = (0,useMergedState/* default */.Z)(id, {
      value: id
    }),
    _useMergedState2 = (0,slicedToArray/* default */.Z)(_useMergedState, 2),
    uuid = _useMergedState2[0],
    setUUID = _useMergedState2[1];
  react.useEffect(function () {
    internalId += 1;
    var newId =  false ? 0 : "".concat(uniquePrefix, "-").concat(internalId);
    setUUID("rc-menu-uuid-".concat(newId));
  }, []);
  return uuid;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__(15671);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__(43144);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js
var inherits = __webpack_require__(60136);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js + 1 modules
var createSuper = __webpack_require__(18486);
// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js
var omit = __webpack_require__(98423);
// EXTERNAL MODULE: ./node_modules/rc-util/es/ref.js
var es_ref = __webpack_require__(42550);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useActive.js


function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  var _React$useContext = react.useContext(MenuContext),
    activeKey = _React$useContext.activeKey,
    onActive = _React$useContext.onActive,
    onInactive = _React$useContext.onInactive;
  var ret = {
    active: activeKey === eventKey
  };

  // Skip when disabled
  if (!disabled) {
    ret.onMouseEnter = function (domEvent) {
      onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
        key: eventKey,
        domEvent: domEvent
      });
      onActive(eventKey);
    };
    ret.onMouseLeave = function (domEvent) {
      onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
        key: eventKey,
        domEvent: domEvent
      });
      onInactive(eventKey);
    };
  }
  return ret;
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useDirectionStyle.js


function useDirectionStyle(level) {
  var _React$useContext = react.useContext(MenuContext),
    mode = _React$useContext.mode,
    rtl = _React$useContext.rtl,
    inlineIndent = _React$useContext.inlineIndent;
  if (mode !== 'inline') {
    return null;
  }
  var len = level;
  return rtl ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/Icon.js


function Icon(_ref) {
  var icon = _ref.icon,
    props = _ref.props,
    children = _ref.children;
  var iconNode;
  if (icon === null || icon === false) {
    return null;
  }
  if (typeof icon === 'function') {
    iconNode = /*#__PURE__*/react.createElement(icon, (0,objectSpread2/* default */.Z)({}, props));
  } else if (typeof icon !== "boolean") {
    // Compatible for origin definition
    iconNode = icon;
  }
  return iconNode || children || null;
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/utils/warnUtil.js

var warnUtil_excluded = ["item"];


/**
 * \`onClick\` event return \`info.item\` which point to react node directly.
 * We should warning this since it will not work on FC.
 */
function warnItemProp(_ref) {
  var item = _ref.item,
    restInfo = (0,objectWithoutProperties/* default */.Z)(_ref, warnUtil_excluded);
  Object.defineProperty(restInfo, 'item', {
    get: function get() {
      (0,warning/* default */.ZP)(false, '\`info.item\` is deprecated since we will move to function component that not provides React Node instance in future.');
      return item;
    }
  });
  return restInfo;
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/MenuItem.js









var MenuItem_excluded = ["title", "attribute", "elementRef"],
  _excluded2 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"],
  _excluded3 = ["active"];















// Since Menu event provide the \`info.item\` which point to the MenuItem node instance.
// We have to use class component here.
// This should be removed from doc & api in future.
var LegacyMenuItem = /*#__PURE__*/function (_React$Component) {
  (0,inherits/* default */.Z)(LegacyMenuItem, _React$Component);
  var _super = (0,createSuper/* default */.Z)(LegacyMenuItem);
  function LegacyMenuItem() {
    (0,classCallCheck/* default */.Z)(this, LegacyMenuItem);
    return _super.apply(this, arguments);
  }
  (0,createClass/* default */.Z)(LegacyMenuItem, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        title = _this$props.title,
        attribute = _this$props.attribute,
        elementRef = _this$props.elementRef,
        restProps = (0,objectWithoutProperties/* default */.Z)(_this$props, MenuItem_excluded);

      // Here the props are eventually passed to the DOM element.
      // React does not recognize non-standard attributes.
      // Therefore, remove the props that is not used here.
      // ref: https://github.com/ant-design/ant-design/issues/41395
      var passedProps = (0,omit/* default */.Z)(restProps, ['eventKey', 'popupClassName', 'popupOffset', 'onTitleClick']);
      (0,warning/* default */.ZP)(!attribute, '\`attribute\` of Menu.Item is deprecated. Please pass attribute directly.');
      return /*#__PURE__*/react.createElement(es/* default */.Z.Item, (0,esm_extends/* default */.Z)({}, attribute, {
        title: typeof title === 'string' ? title : undefined
      }, passedProps, {
        ref: elementRef
      }));
    }
  }]);
  return LegacyMenuItem;
}(react.Component);
/**
 * Real Menu Item component
 */
var InternalMenuItem = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var style = props.style,
    className = props.className,
    eventKey = props.eventKey,
    warnKey = props.warnKey,
    disabled = props.disabled,
    itemIcon = props.itemIcon,
    children = props.children,
    role = props.role,
    onMouseEnter = props.onMouseEnter,
    onMouseLeave = props.onMouseLeave,
    onClick = props.onClick,
    onKeyDown = props.onKeyDown,
    onFocus = props.onFocus,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, _excluded2);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls,
    onItemClick = _React$useContext.onItemClick,
    contextDisabled = _React$useContext.disabled,
    overflowDisabled = _React$useContext.overflowDisabled,
    contextItemIcon = _React$useContext.itemIcon,
    selectedKeys = _React$useContext.selectedKeys,
    onActive = _React$useContext.onActive;
  var _React$useContext2 = react.useContext(context_PrivateContext),
    _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
  var itemCls = "".concat(prefixCls, "-item");
  var legacyMenuItemRef = react.useRef();
  var elementRef = react.useRef();
  var mergedDisabled = contextDisabled || disabled;
  var mergedEleRef = (0,es_ref/* useComposeRef */.x1)(ref, elementRef);
  var connectedKeys = useFullPath(eventKey);

  // ================================ Warn ================================
  if (false) {}

  // ============================= Info =============================
  var getEventInfo = function getEventInfo(e) {
    return {
      key: eventKey,
      // Note: For legacy code is reversed which not like other antd component
      keyPath: (0,toConsumableArray/* default */.Z)(connectedKeys).reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e
    };
  };

  // ============================= Icon =============================
  var mergedItemIcon = itemIcon || contextItemIcon;

  // ============================ Active ============================
  var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave),
    active = _useActive.active,
    activeProps = (0,objectWithoutProperties/* default */.Z)(_useActive, _excluded3);

  // ============================ Select ============================
  var selected = selectedKeys.includes(eventKey);

  // ======================== DirectionStyle ========================
  var directionStyle = useDirectionStyle(connectedKeys.length);

  // ============================ Events ============================
  var onInternalClick = function onInternalClick(e) {
    if (mergedDisabled) {
      return;
    }
    var info = getEventInfo(e);
    onClick === null || onClick === void 0 || onClick(warnItemProp(info));
    onItemClick(info);
  };
  var onInternalKeyDown = function onInternalKeyDown(e) {
    onKeyDown === null || onKeyDown === void 0 || onKeyDown(e);
    if (e.which === KeyCode/* default */.Z.ENTER) {
      var info = getEventInfo(e);

      // Legacy. Key will also trigger click event
      onClick === null || onClick === void 0 || onClick(warnItemProp(info));
      onItemClick(info);
    }
  };

  /**
   * Used for accessibility. Helper will focus element without key board.
   * We should manually trigger an active
   */
  var onInternalFocus = function onInternalFocus(e) {
    onActive(eventKey);
    onFocus === null || onFocus === void 0 || onFocus(e);
  };

  // ============================ Render ============================
  var optionRoleProps = {};
  if (props.role === 'option') {
    optionRoleProps['aria-selected'] = selected;
  }
  var renderNode = /*#__PURE__*/react.createElement(LegacyMenuItem, (0,esm_extends/* default */.Z)({
    ref: legacyMenuItemRef,
    elementRef: mergedEleRef,
    role: role === null ? 'none' : role || 'menuitem',
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId
  }, (0,omit/* default */.Z)(restProps, ['extra']), activeProps, optionRoleProps, {
    component: "li",
    "aria-disabled": disabled,
    style: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, directionStyle), style),
    className: classnames_default()(itemCls, (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, "".concat(itemCls, "-active"), active), "".concat(itemCls, "-selected"), selected), "".concat(itemCls, "-disabled"), mergedDisabled), className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus
  }), children, /*#__PURE__*/react.createElement(Icon, {
    props: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, props), {}, {
      isSelected: selected
    }),
    icon: mergedItemIcon
  }));
  if (_internalRenderMenuItem) {
    renderNode = _internalRenderMenuItem(renderNode, props, {
      selected: selected
    });
  }
  return renderNode;
});
function MenuItem(props, ref) {
  var eventKey = props.eventKey;

  // ==================== Record KeyPath ====================
  var measure = useMeasure();
  var connectedKeyPath = useFullPath(eventKey);

  // eslint-disable-next-line consistent-return
  react.useEffect(function () {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function () {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  }

  // ======================== Render ========================
  return /*#__PURE__*/react.createElement(InternalMenuItem, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref
  }));
}
/* harmony default export */ var es_MenuItem = (/*#__PURE__*/react.forwardRef(MenuItem));
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/SubMenu/SubMenuList.js


var SubMenuList_excluded = ["className", "children"];



var InternalSubMenuList = function InternalSubMenuList(_ref, ref) {
  var className = _ref.className,
    children = _ref.children,
    restProps = (0,objectWithoutProperties/* default */.Z)(_ref, SubMenuList_excluded);
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls,
    mode = _React$useContext.mode,
    rtl = _React$useContext.rtl;
  return /*#__PURE__*/react.createElement("ul", (0,esm_extends/* default */.Z)({
    className: classnames_default()(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === 'inline' ? 'inline' : 'vertical'), className),
    role: "menu"
  }, restProps, {
    "data-menu-list": true,
    ref: ref
  }), children);
};
var SubMenuList = /*#__PURE__*/react.forwardRef(InternalSubMenuList);
SubMenuList.displayName = 'SubMenuList';
/* harmony default export */ var SubMenu_SubMenuList = (SubMenuList);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Children/toArray.js
var toArray = __webpack_require__(50344);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/utils/commonUtil.js



function parseChildren(children, keyPath) {
  return (0,toArray/* default */.Z)(children).map(function (child, index) {
    if ( /*#__PURE__*/react.isValidElement(child)) {
      var _eventKey, _child$props;
      var key = child.key;
      var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
      var emptyKey = eventKey === null || eventKey === undefined;
      if (emptyKey) {
        eventKey = "tmp_key-".concat([].concat((0,toConsumableArray/* default */.Z)(keyPath), [index]).join('-'));
      }
      var cloneProps = {
        key: eventKey,
        eventKey: eventKey
      };
      if (false) {}
      return /*#__PURE__*/react.cloneElement(child, cloneProps);
    }
    return child;
  });
}
// EXTERNAL MODULE: ./node_modules/@rc-component/trigger/es/index.js + 11 modules
var trigger_es = __webpack_require__(40228);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/placements.js
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var placements = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflow
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflow
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: autoAdjustOverflow
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: autoAdjustOverflow
  }
};
var placementsRtl = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflow
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflow
  },
  rightTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow
  },
  rightBottom: {
    points: ['br', 'bl'],
    overflow: autoAdjustOverflow
  },
  leftTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow
  },
  leftBottom: {
    points: ['bl', 'br'],
    overflow: autoAdjustOverflow
  }
};
/* harmony default export */ var es_placements = ((/* unused pure expression or super */ null && (placements)));
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/utils/motionUtil.js
function getMotion(mode, motion, defaultMotions) {
  if (motion) {
    return motion;
  }
  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }
  return undefined;
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/SubMenu/PopupTrigger.js










var popupPlacementMap = {
  horizontal: 'bottomLeft',
  vertical: 'rightTop',
  'vertical-left': 'rightTop',
  'vertical-right': 'leftTop'
};
function PopupTrigger(_ref) {
  var prefixCls = _ref.prefixCls,
    visible = _ref.visible,
    children = _ref.children,
    popup = _ref.popup,
    popupStyle = _ref.popupStyle,
    popupClassName = _ref.popupClassName,
    popupOffset = _ref.popupOffset,
    disabled = _ref.disabled,
    mode = _ref.mode,
    onVisibleChange = _ref.onVisibleChange;
  var _React$useContext = react.useContext(MenuContext),
    getPopupContainer = _React$useContext.getPopupContainer,
    rtl = _React$useContext.rtl,
    subMenuOpenDelay = _React$useContext.subMenuOpenDelay,
    subMenuCloseDelay = _React$useContext.subMenuCloseDelay,
    builtinPlacements = _React$useContext.builtinPlacements,
    triggerSubMenuAction = _React$useContext.triggerSubMenuAction,
    forceSubMenuRender = _React$useContext.forceSubMenuRender,
    rootClassName = _React$useContext.rootClassName,
    motion = _React$useContext.motion,
    defaultMotions = _React$useContext.defaultMotions;
  var _React$useState = react.useState(false),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    innerVisible = _React$useState2[0],
    setInnerVisible = _React$useState2[1];
  var placement = rtl ? (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, placementsRtl), builtinPlacements) : (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, placements), builtinPlacements);
  var popupPlacement = popupPlacementMap[mode];
  var targetMotion = getMotion(mode, motion, defaultMotions);
  var targetMotionRef = react.useRef(targetMotion);
  if (mode !== 'inline') {
    /**
     * PopupTrigger is only used for vertical and horizontal types.
     * When collapsed is unfolded, the inline animation will destroy the vertical animation.
     */
    targetMotionRef.current = targetMotion;
  }
  var mergedMotion = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, targetMotionRef.current), {}, {
    leavedClassName: "".concat(prefixCls, "-hidden"),
    removeOnLeave: false,
    motionAppear: true
  });

  // Delay to change visible
  var visibleRef = react.useRef();
  react.useEffect(function () {
    visibleRef.current = (0,raf/* default */.Z)(function () {
      setInnerVisible(visible);
    });
    return function () {
      raf/* default */.Z.cancel(visibleRef.current);
    };
  }, [visible]);
  return /*#__PURE__*/react.createElement(trigger_es/* default */.Z, {
    prefixCls: prefixCls,
    popupClassName: classnames_default()("".concat(prefixCls, "-popup"), (0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
    stretch: mode === 'horizontal' ? 'minWidth' : null,
    getPopupContainer: getPopupContainer,
    builtinPlacements: placement,
    popupPlacement: popupPlacement,
    popupVisible: innerVisible,
    popup: popup,
    popupStyle: popupStyle,
    popupAlign: popupOffset && {
      offset: popupOffset
    },
    action: disabled ? [] : [triggerSubMenuAction],
    mouseEnterDelay: subMenuOpenDelay,
    mouseLeaveDelay: subMenuCloseDelay,
    onPopupVisibleChange: onVisibleChange,
    forceRender: forceSubMenuRender,
    popupMotion: mergedMotion,
    fresh: true
  }, children);
}
// EXTERNAL MODULE: ./node_modules/rc-motion/es/index.js + 13 modules
var rc_motion_es = __webpack_require__(29372);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/SubMenu/InlineSubMenuList.js








function InlineSubMenuList(_ref) {
  var id = _ref.id,
    open = _ref.open,
    keyPath = _ref.keyPath,
    children = _ref.children;
  var fixedMode = 'inline';
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls,
    forceSubMenuRender = _React$useContext.forceSubMenuRender,
    motion = _React$useContext.motion,
    defaultMotions = _React$useContext.defaultMotions,
    mode = _React$useContext.mode;

  // Always use latest mode check
  var sameModeRef = react.useRef(false);
  sameModeRef.current = mode === fixedMode;

  // We record \`destroy\` mark here since when mode change from \`inline\` to others.
  // The inline list should remove when motion end.
  var _React$useState = react.useState(!sameModeRef.current),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    destroy = _React$useState2[0],
    setDestroy = _React$useState2[1];
  var mergedOpen = sameModeRef.current ? open : false;

  // ================================= Effect =================================
  // Reset destroy state when mode change back
  react.useEffect(function () {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]);

  // ================================= Render =================================
  var mergedMotion = (0,objectSpread2/* default */.Z)({}, getMotion(fixedMode, motion, defaultMotions));

  // No need appear since nest inlineCollapse changed
  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  }

  // Hide inline list when mode changed and motion end
  var originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = function (newVisible) {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
  };
  if (destroy) {
    return null;
  }
  return /*#__PURE__*/react.createElement(InheritableContextProvider, {
    mode: fixedMode,
    locked: !sameModeRef.current
  }, /*#__PURE__*/react.createElement(rc_motion_es/* default */.ZP, (0,esm_extends/* default */.Z)({
    visible: mergedOpen
  }, mergedMotion, {
    forceRender: forceSubMenuRender,
    removeOnLeave: false,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }), function (_ref2) {
    var motionClassName = _ref2.className,
      motionStyle = _ref2.style;
    return /*#__PURE__*/react.createElement(SubMenu_SubMenuList, {
      id: id,
      className: motionClassName,
      style: motionStyle
    }, children);
  }));
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/SubMenu/index.js





var SubMenu_excluded = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "popupStyle", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"],
  SubMenu_excluded2 = ["active"];

















var InternalSubMenu = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var style = props.style,
    className = props.className,
    title = props.title,
    eventKey = props.eventKey,
    warnKey = props.warnKey,
    disabled = props.disabled,
    internalPopupClose = props.internalPopupClose,
    children = props.children,
    itemIcon = props.itemIcon,
    expandIcon = props.expandIcon,
    popupClassName = props.popupClassName,
    popupOffset = props.popupOffset,
    popupStyle = props.popupStyle,
    onClick = props.onClick,
    onMouseEnter = props.onMouseEnter,
    onMouseLeave = props.onMouseLeave,
    onTitleClick = props.onTitleClick,
    onTitleMouseEnter = props.onTitleMouseEnter,
    onTitleMouseLeave = props.onTitleMouseLeave,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, SubMenu_excluded);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls,
    mode = _React$useContext.mode,
    openKeys = _React$useContext.openKeys,
    contextDisabled = _React$useContext.disabled,
    overflowDisabled = _React$useContext.overflowDisabled,
    activeKey = _React$useContext.activeKey,
    selectedKeys = _React$useContext.selectedKeys,
    contextItemIcon = _React$useContext.itemIcon,
    contextExpandIcon = _React$useContext.expandIcon,
    onItemClick = _React$useContext.onItemClick,
    onOpenChange = _React$useContext.onOpenChange,
    onActive = _React$useContext.onActive;
  var _React$useContext2 = react.useContext(context_PrivateContext),
    _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
  var _React$useContext3 = react.useContext(PathUserContext),
    isSubPathKey = _React$useContext3.isSubPathKey;
  var connectedPath = useFullPath();
  var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
  var mergedDisabled = contextDisabled || disabled;
  var elementRef = react.useRef();
  var popupRef = react.useRef();

  // ================================ Warn ================================
  if (false) {}

  // ================================ Icon ================================
  var mergedItemIcon = itemIcon !== null && itemIcon !== void 0 ? itemIcon : contextItemIcon;
  var mergedExpandIcon = expandIcon !== null && expandIcon !== void 0 ? expandIcon : contextExpandIcon;

  // ================================ Open ================================
  var originOpen = openKeys.includes(eventKey);
  var open = !overflowDisabled && originOpen;

  // =============================== Select ===============================
  var childrenSelected = isSubPathKey(selectedKeys, eventKey);

  // =============================== Active ===============================
  var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave),
    active = _useActive.active,
    activeProps = (0,objectWithoutProperties/* default */.Z)(_useActive, SubMenu_excluded2);

  // Fallback of active check to avoid hover on menu title or disabled item
  var _React$useState = react.useState(false),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    childrenActive = _React$useState2[0],
    setChildrenActive = _React$useState2[1];
  var triggerChildrenActive = function triggerChildrenActive(newActive) {
    if (!mergedDisabled) {
      setChildrenActive(newActive);
    }
  };
  var onInternalMouseEnter = function onInternalMouseEnter(domEvent) {
    triggerChildrenActive(true);
    onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
      key: eventKey,
      domEvent: domEvent
    });
  };
  var onInternalMouseLeave = function onInternalMouseLeave(domEvent) {
    triggerChildrenActive(false);
    onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
      key: eventKey,
      domEvent: domEvent
    });
  };
  var mergedActive = react.useMemo(function () {
    if (active) {
      return active;
    }
    if (mode !== 'inline') {
      return childrenActive || isSubPathKey([activeKey], eventKey);
    }
    return false;
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);

  // ========================== DirectionStyle ==========================
  var directionStyle = useDirectionStyle(connectedPath.length);

  // =============================== Events ===============================
  // >>>> Title click
  var onInternalTitleClick = function onInternalTitleClick(e) {
    // Skip if disabled
    if (mergedDisabled) {
      return;
    }
    onTitleClick === null || onTitleClick === void 0 || onTitleClick({
      key: eventKey,
      domEvent: e
    });

    // Trigger open by click when mode is \`inline\`
    if (mode === 'inline') {
      onOpenChange(eventKey, !originOpen);
    }
  };

  // >>>> Context for children click
  var onMergedItemClick = useMemoCallback(function (info) {
    onClick === null || onClick === void 0 || onClick(warnItemProp(info));
    onItemClick(info);
  });

  // >>>>> Visible change
  var onPopupVisibleChange = function onPopupVisibleChange(newVisible) {
    if (mode !== 'inline') {
      onOpenChange(eventKey, newVisible);
    }
  };

  /**
   * Used for accessibility. Helper will focus element without key board.
   * We should manually trigger an active
   */
  var onInternalFocus = function onInternalFocus() {
    onActive(eventKey);
  };

  // =============================== Render ===============================
  var popupId = domDataId && "".concat(domDataId, "-popup");

  // >>>>> Title
  var titleNode = /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.Z)({
    role: "menuitem",
    style: directionStyle,
    className: "".concat(subMenuPrefixCls, "-title"),
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title === 'string' ? title : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open,
    "aria-haspopup": true,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus
  }, activeProps), title, /*#__PURE__*/react.createElement(Icon, {
    icon: mode !== 'horizontal' ? mergedExpandIcon : undefined,
    props: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, props), {}, {
      isOpen: open,
      // [Legacy] Not sure why need this mark
      isSubMenu: true
    })
  }, /*#__PURE__*/react.createElement("i", {
    className: "".concat(subMenuPrefixCls, "-arrow")
  })));

  // Cache mode if it change to \`inline\` which do not have popup motion
  var triggerModeRef = react.useRef(mode);
  if (mode !== 'inline' && connectedPath.length > 1) {
    triggerModeRef.current = 'vertical';
  } else {
    triggerModeRef.current = mode;
  }
  if (!overflowDisabled) {
    var triggerMode = triggerModeRef.current;

    // Still wrap with Trigger here since we need avoid react re-mount dom node
    // Which makes motion failed
    titleNode = /*#__PURE__*/react.createElement(PopupTrigger, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open && mode !== 'inline',
      popupClassName: popupClassName,
      popupOffset: popupOffset,
      popupStyle: popupStyle,
      popup: /*#__PURE__*/react.createElement(InheritableContextProvider
      // Special handle of horizontal mode
      , {
        mode: triggerMode === 'horizontal' ? 'vertical' : triggerMode
      }, /*#__PURE__*/react.createElement(SubMenu_SubMenuList, {
        id: popupId,
        ref: popupRef
      }, children)),
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange
    }, titleNode);
  }

  // >>>>> List node
  var listNode = /*#__PURE__*/react.createElement(es/* default */.Z.Item, (0,esm_extends/* default */.Z)({
    ref: ref,
    role: "none"
  }, restProps, {
    component: "li",
    style: style,
    className: classnames_default()(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, "".concat(subMenuPrefixCls, "-open"), open), "".concat(subMenuPrefixCls, "-active"), mergedActive), "".concat(subMenuPrefixCls, "-selected"), childrenSelected), "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled)),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave
  }), titleNode, !overflowDisabled && /*#__PURE__*/react.createElement(InlineSubMenuList, {
    id: popupId,
    open: open,
    keyPath: connectedPath
  }, children));
  if (_internalRenderSubMenuItem) {
    listNode = _internalRenderSubMenuItem(listNode, props, {
      selected: childrenSelected,
      active: mergedActive,
      open: open,
      disabled: mergedDisabled
    });
  }

  // >>>>> Render
  return /*#__PURE__*/react.createElement(InheritableContextProvider, {
    onItemClick: onMergedItemClick,
    mode: mode === 'horizontal' ? 'vertical' : mode,
    itemIcon: mergedItemIcon,
    expandIcon: mergedExpandIcon
  }, listNode);
});
var SubMenu = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var eventKey = props.eventKey,
    children = props.children;
  var connectedKeyPath = useFullPath(eventKey);
  var childList = parseChildren(children, connectedKeyPath);

  // ==================== Record KeyPath ====================
  var measure = useMeasure();

  // eslint-disable-next-line consistent-return
  react.useEffect(function () {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function () {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  var renderNode;

  // ======================== Render ========================
  if (measure) {
    renderNode = childList;
  } else {
    renderNode = /*#__PURE__*/react.createElement(InternalSubMenu, (0,esm_extends/* default */.Z)({
      ref: ref
    }, props), childList);
  }
  return /*#__PURE__*/react.createElement(PathTrackerContext.Provider, {
    value: connectedKeyPath
  }, renderNode);
});
if (false) {}
/* harmony default export */ var es_SubMenu = (SubMenu);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(71002);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/Divider.js




function Divider(_ref) {
  var className = _ref.className,
    style = _ref.style;
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls;
  var measure = useMeasure();
  if (measure) {
    return null;
  }
  return /*#__PURE__*/react.createElement("li", {
    role: "separator",
    className: classnames_default()("".concat(prefixCls, "-item-divider"), className),
    style: style
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/MenuItemGroup.js


var MenuItemGroup_excluded = ["className", "title", "eventKey", "children"];






var InternalMenuItemGroup = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var className = props.className,
    title = props.title,
    eventKey = props.eventKey,
    children = props.children,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, MenuItemGroup_excluded);
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls;
  var groupPrefixCls = "".concat(prefixCls, "-item-group");
  return /*#__PURE__*/react.createElement("li", (0,esm_extends/* default */.Z)({
    ref: ref,
    role: "presentation"
  }, restProps, {
    onClick: function onClick(e) {
      return e.stopPropagation();
    },
    className: classnames_default()(groupPrefixCls, className)
  }), /*#__PURE__*/react.createElement("div", {
    role: "presentation",
    className: "".concat(groupPrefixCls, "-title"),
    title: typeof title === 'string' ? title : undefined
  }, title), /*#__PURE__*/react.createElement("ul", {
    role: "group",
    className: "".concat(groupPrefixCls, "-list")
  }, children));
});
var MenuItemGroup = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var eventKey = props.eventKey,
    children = props.children;
  var connectedKeyPath = useFullPath(eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  if (measure) {
    return childList;
  }
  return /*#__PURE__*/react.createElement(InternalMenuItemGroup, (0,esm_extends/* default */.Z)({
    ref: ref
  }, (0,omit/* default */.Z)(props, ['warnKey'])), childList);
});
if (false) {}
/* harmony default export */ var es_MenuItemGroup = (MenuItemGroup);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/utils/nodeUtil.js




var nodeUtil_excluded = ["label", "children", "key", "type", "extra"];






function convertItemsToNodes(list, components, prefixCls) {
  var MergedMenuItem = components.item,
    MergedMenuItemGroup = components.group,
    MergedSubMenu = components.submenu,
    MergedDivider = components.divider;
  return (list || []).map(function (opt, index) {
    if (opt && (0,esm_typeof/* default */.Z)(opt) === 'object') {
      var _ref = opt,
        label = _ref.label,
        children = _ref.children,
        key = _ref.key,
        type = _ref.type,
        extra = _ref.extra,
        restProps = (0,objectWithoutProperties/* default */.Z)(_ref, nodeUtil_excluded);
      var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index);

      // MenuItemGroup & SubMenuItem
      if (children || type === 'group') {
        if (type === 'group') {
          // Group
          return /*#__PURE__*/react.createElement(MergedMenuItemGroup, (0,esm_extends/* default */.Z)({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes(children, components, prefixCls));
        }

        // Sub Menu
        return /*#__PURE__*/react.createElement(MergedSubMenu, (0,esm_extends/* default */.Z)({
          key: mergedKey
        }, restProps, {
          title: label
        }), convertItemsToNodes(children, components, prefixCls));
      }

      // MenuItem & Divider
      if (type === 'divider') {
        return /*#__PURE__*/react.createElement(MergedDivider, (0,esm_extends/* default */.Z)({
          key: mergedKey
        }, restProps));
      }
      return /*#__PURE__*/react.createElement(MergedMenuItem, (0,esm_extends/* default */.Z)({
        key: mergedKey
      }, restProps, {
        extra: extra
      }), label, (!!extra || extra === 0) && /*#__PURE__*/react.createElement("span", {
        className: "".concat(prefixCls, "-item-extra")
      }, extra));
    }
    return null;
  }).filter(function (opt) {
    return opt;
  });
}
function parseItems(children, items, keyPath, components, prefixCls) {
  var childNodes = children;
  var mergedComponents = (0,objectSpread2/* default */.Z)({
    divider: Divider,
    item: es_MenuItem,
    group: es_MenuItemGroup,
    submenu: es_SubMenu
  }, components);
  if (items) {
    childNodes = convertItemsToNodes(items, mergedComponents, prefixCls);
  }
  return parseChildren(childNodes, keyPath);
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/Menu.js






var Menu_excluded = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem", "_internalComponents"];





















/**
 * Menu modify after refactor:
 * ## Add
 * - disabled
 *
 * ## Remove
 * - openTransitionName
 * - openAnimation
 * - onDestroy
 * - siderCollapsed: Seems antd do not use this prop (Need test in antd)
 * - collapsedWidth: Seems this logic should be handle by antd Layout.Sider
 */

// optimize for render
var EMPTY_LIST = [];
var Menu = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var _childList$;
  var _ref = props,
    _ref$prefixCls = _ref.prefixCls,
    prefixCls = _ref$prefixCls === void 0 ? 'rc-menu' : _ref$prefixCls,
    rootClassName = _ref.rootClassName,
    style = _ref.style,
    className = _ref.className,
    _ref$tabIndex = _ref.tabIndex,
    tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
    items = _ref.items,
    children = _ref.children,
    direction = _ref.direction,
    id = _ref.id,
    _ref$mode = _ref.mode,
    mode = _ref$mode === void 0 ? 'vertical' : _ref$mode,
    inlineCollapsed = _ref.inlineCollapsed,
    disabled = _ref.disabled,
    disabledOverflow = _ref.disabledOverflow,
    _ref$subMenuOpenDelay = _ref.subMenuOpenDelay,
    subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay,
    _ref$subMenuCloseDela = _ref.subMenuCloseDelay,
    subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela,
    forceSubMenuRender = _ref.forceSubMenuRender,
    defaultOpenKeys = _ref.defaultOpenKeys,
    openKeys = _ref.openKeys,
    activeKey = _ref.activeKey,
    defaultActiveFirst = _ref.defaultActiveFirst,
    _ref$selectable = _ref.selectable,
    selectable = _ref$selectable === void 0 ? true : _ref$selectable,
    _ref$multiple = _ref.multiple,
    multiple = _ref$multiple === void 0 ? false : _ref$multiple,
    defaultSelectedKeys = _ref.defaultSelectedKeys,
    selectedKeys = _ref.selectedKeys,
    onSelect = _ref.onSelect,
    onDeselect = _ref.onDeselect,
    _ref$inlineIndent = _ref.inlineIndent,
    inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent,
    motion = _ref.motion,
    defaultMotions = _ref.defaultMotions,
    _ref$triggerSubMenuAc = _ref.triggerSubMenuAction,
    triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? 'hover' : _ref$triggerSubMenuAc,
    builtinPlacements = _ref.builtinPlacements,
    itemIcon = _ref.itemIcon,
    expandIcon = _ref.expandIcon,
    _ref$overflowedIndica = _ref.overflowedIndicator,
    overflowedIndicator = _ref$overflowedIndica === void 0 ? '...' : _ref$overflowedIndica,
    overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName,
    getPopupContainer = _ref.getPopupContainer,
    onClick = _ref.onClick,
    onOpenChange = _ref.onOpenChange,
    onKeyDown = _ref.onKeyDown,
    openAnimation = _ref.openAnimation,
    openTransitionName = _ref.openTransitionName,
    _internalRenderMenuItem = _ref._internalRenderMenuItem,
    _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem,
    _internalComponents = _ref._internalComponents,
    restProps = (0,objectWithoutProperties/* default */.Z)(_ref, Menu_excluded);
  var _React$useMemo = react.useMemo(function () {
      return [parseItems(children, items, EMPTY_LIST, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST, {}, prefixCls)];
    }, [children, items, _internalComponents]),
    _React$useMemo2 = (0,slicedToArray/* default */.Z)(_React$useMemo, 2),
    childList = _React$useMemo2[0],
    measureChildList = _React$useMemo2[1];
  var _React$useState = react.useState(false),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    mounted = _React$useState2[0],
    setMounted = _React$useState2[1];
  var containerRef = react.useRef();
  var uuid = useUUID(id);
  var isRtl = direction === 'rtl';

  // ========================= Warn =========================
  if (false) {}

  // ========================= Open =========================
  var _useMergedState = (0,useMergedState/* default */.Z)(defaultOpenKeys, {
      value: openKeys,
      postState: function postState(keys) {
        return keys || EMPTY_LIST;
      }
    }),
    _useMergedState2 = (0,slicedToArray/* default */.Z)(_useMergedState, 2),
    mergedOpenKeys = _useMergedState2[0],
    setMergedOpenKeys = _useMergedState2[1];

  // React 18 will merge mouse event which means we open key will not sync
  // ref: https://github.com/ant-design/ant-design/issues/38818
  var triggerOpenKeys = function triggerOpenKeys(keys) {
    var forceFlush = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    function doUpdate() {
      setMergedOpenKeys(keys);
      onOpenChange === null || onOpenChange === void 0 || onOpenChange(keys);
    }
    if (forceFlush) {
      (0,react_dom.flushSync)(doUpdate);
    } else {
      doUpdate();
    }
  };

  // >>>>> Cache & Reset open keys when inlineCollapsed changed
  var _React$useState3 = react.useState(mergedOpenKeys),
    _React$useState4 = (0,slicedToArray/* default */.Z)(_React$useState3, 2),
    inlineCacheOpenKeys = _React$useState4[0],
    setInlineCacheOpenKeys = _React$useState4[1];
  var mountRef = react.useRef(false);

  // ========================= Mode =========================
  var _React$useMemo3 = react.useMemo(function () {
      if ((mode === 'inline' || mode === 'vertical') && inlineCollapsed) {
        return ['vertical', inlineCollapsed];
      }
      return [mode, false];
    }, [mode, inlineCollapsed]),
    _React$useMemo4 = (0,slicedToArray/* default */.Z)(_React$useMemo3, 2),
    mergedMode = _React$useMemo4[0],
    mergedInlineCollapsed = _React$useMemo4[1];
  var isInlineMode = mergedMode === 'inline';
  var _React$useState5 = react.useState(mergedMode),
    _React$useState6 = (0,slicedToArray/* default */.Z)(_React$useState5, 2),
    internalMode = _React$useState6[0],
    setInternalMode = _React$useState6[1];
  var _React$useState7 = react.useState(mergedInlineCollapsed),
    _React$useState8 = (0,slicedToArray/* default */.Z)(_React$useState7, 2),
    internalInlineCollapsed = _React$useState8[0],
    setInternalInlineCollapsed = _React$useState8[1];
  react.useEffect(function () {
    setInternalMode(mergedMode);
    setInternalInlineCollapsed(mergedInlineCollapsed);
    if (!mountRef.current) {
      return;
    }
    // Synchronously update MergedOpenKeys
    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      // Trigger open event in case its in control
      triggerOpenKeys(EMPTY_LIST);
    }
  }, [mergedMode, mergedInlineCollapsed]);

  // ====================== Responsive ======================
  var _React$useState9 = react.useState(0),
    _React$useState10 = (0,slicedToArray/* default */.Z)(_React$useState9, 2),
    lastVisibleIndex = _React$useState10[0],
    setLastVisibleIndex = _React$useState10[1];
  var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== 'horizontal' || disabledOverflow;

  // Cache
  react.useEffect(function () {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  react.useEffect(function () {
    mountRef.current = true;
    return function () {
      mountRef.current = false;
    };
  }, []);

  // ========================= Path =========================
  var _useKeyRecords = useKeyRecords(),
    registerPath = _useKeyRecords.registerPath,
    unregisterPath = _useKeyRecords.unregisterPath,
    refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys,
    isSubPathKey = _useKeyRecords.isSubPathKey,
    getKeyPath = _useKeyRecords.getKeyPath,
    getKeys = _useKeyRecords.getKeys,
    getSubPathKeys = _useKeyRecords.getSubPathKeys;
  var registerPathContext = react.useMemo(function () {
    return {
      registerPath: registerPath,
      unregisterPath: unregisterPath
    };
  }, [registerPath, unregisterPath]);
  var pathUserContext = react.useMemo(function () {
    return {
      isSubPathKey: isSubPathKey
    };
  }, [isSubPathKey]);
  react.useEffect(function () {
    refreshOverflowKeys(allVisible ? EMPTY_LIST : childList.slice(lastVisibleIndex + 1).map(function (child) {
      return child.key;
    }));
  }, [lastVisibleIndex, allVisible]);

  // ======================== Active ========================
  var _useMergedState3 = (0,useMergedState/* default */.Z)(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
      value: activeKey
    }),
    _useMergedState4 = (0,slicedToArray/* default */.Z)(_useMergedState3, 2),
    mergedActiveKey = _useMergedState4[0],
    setMergedActiveKey = _useMergedState4[1];
  var onActive = useMemoCallback(function (key) {
    setMergedActiveKey(key);
  });
  var onInactive = useMemoCallback(function () {
    setMergedActiveKey(undefined);
  });
  (0,react.useImperativeHandle)(ref, function () {
    return {
      list: containerRef.current,
      focus: function focus(options) {
        var _childList$find;
        var keys = getKeys();
        var _refreshElements = refreshElements(keys, uuid),
          elements = _refreshElements.elements,
          key2element = _refreshElements.key2element,
          element2key = _refreshElements.element2key;
        var focusableElements = getFocusableElements(containerRef.current, elements);
        var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : focusableElements[0] ? element2key.get(focusableElements[0]) : (_childList$find = childList.find(function (node) {
          return !node.props.disabled;
        })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
        var elementToFocus = key2element.get(shouldFocusKey);
        if (shouldFocusKey && elementToFocus) {
          var _elementToFocus$focus;
          elementToFocus === null || elementToFocus === void 0 || (_elementToFocus$focus = elementToFocus.focus) === null || _elementToFocus$focus === void 0 || _elementToFocus$focus.call(elementToFocus, options);
        }
      }
    };
  });

  // ======================== Select ========================
  // >>>>> Select keys
  var _useMergedState5 = (0,useMergedState/* default */.Z)(defaultSelectedKeys || [], {
      value: selectedKeys,
      // Legacy convert key to array
      postState: function postState(keys) {
        if (Array.isArray(keys)) {
          return keys;
        }
        if (keys === null || keys === undefined) {
          return EMPTY_LIST;
        }
        return [keys];
      }
    }),
    _useMergedState6 = (0,slicedToArray/* default */.Z)(_useMergedState5, 2),
    mergedSelectKeys = _useMergedState6[0],
    setMergedSelectKeys = _useMergedState6[1];

  // >>>>> Trigger select
  var triggerSelection = function triggerSelection(info) {
    if (selectable) {
      // Insert or Remove
      var targetKey = info.key;
      var exist = mergedSelectKeys.includes(targetKey);
      var newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter(function (key) {
            return key !== targetKey;
          });
        } else {
          newSelectKeys = [].concat((0,toConsumableArray/* default */.Z)(mergedSelectKeys), [targetKey]);
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys);

      // Trigger event
      var selectInfo = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, info), {}, {
        selectedKeys: newSelectKeys
      });
      if (exist) {
        onDeselect === null || onDeselect === void 0 || onDeselect(selectInfo);
      } else {
        onSelect === null || onSelect === void 0 || onSelect(selectInfo);
      }
    }

    // Whatever selectable, always close it
    if (!multiple && mergedOpenKeys.length && internalMode !== 'inline') {
      triggerOpenKeys(EMPTY_LIST);
    }
  };

  // ========================= Open =========================
  /**
   * Click for item. SubMenu do not have selection status
   */
  var onInternalClick = useMemoCallback(function (info) {
    onClick === null || onClick === void 0 || onClick(warnItemProp(info));
    triggerSelection(info);
  });
  var onInternalOpenChange = useMemoCallback(function (key, open) {
    var newOpenKeys = mergedOpenKeys.filter(function (k) {
      return k !== key;
    });
    if (open) {
      newOpenKeys.push(key);
    } else if (internalMode !== 'inline') {
      // We need find all related popup to close
      var subPathKeys = getSubPathKeys(key);
      newOpenKeys = newOpenKeys.filter(function (k) {
        return !subPathKeys.has(k);
      });
    }
    if (!(0,isEqual/* default */.Z)(mergedOpenKeys, newOpenKeys, true)) {
      triggerOpenKeys(newOpenKeys, true);
    }
  });

  // ==================== Accessibility =====================
  var triggerAccessibilityOpen = function triggerAccessibilityOpen(key, open) {
    var nextOpen = open !== null && open !== void 0 ? open : !mergedOpenKeys.includes(key);
    onInternalOpenChange(key, nextOpen);
  };
  var onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown);

  // ======================== Effect ========================
  react.useEffect(function () {
    setMounted(true);
  }, []);

  // ======================= Context ========================
  var privateContext = react.useMemo(function () {
    return {
      _internalRenderMenuItem: _internalRenderMenuItem,
      _internalRenderSubMenuItem: _internalRenderSubMenuItem
    };
  }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);

  // ======================== Render ========================

  // >>>>> Children
  var wrappedChildList = internalMode !== 'horizontal' || disabledOverflow ? childList :
  // Need wrap for overflow dropdown that do not response for open
  childList.map(function (child, index) {
    return (
      /*#__PURE__*/
      // Always wrap provider to avoid sub node re-mount
      react.createElement(InheritableContextProvider, {
        key: child.key,
        overflowDisabled: index > lastVisibleIndex
      }, child)
    );
  });

  // >>>>> Container
  var container = /*#__PURE__*/react.createElement(es/* default */.Z, (0,esm_extends/* default */.Z)({
    id: id,
    ref: containerRef,
    prefixCls: "".concat(prefixCls, "-overflow"),
    component: "ul",
    itemComponent: es_MenuItem,
    className: classnames_default()(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), "".concat(prefixCls, "-rtl"), isRtl), rootClassName),
    dir: direction,
    style: style,
    role: "menu",
    tabIndex: tabIndex,
    data: wrappedChildList,
    renderRawItem: function renderRawItem(node) {
      return node;
    },
    renderRawRest: function renderRawRest(omitItems) {
      // We use origin list since wrapped list use context to prevent open
      var len = omitItems.length;
      var originOmitItems = len ? childList.slice(-len) : null;
      return /*#__PURE__*/react.createElement(es_SubMenu, {
        eventKey: OVERFLOW_KEY,
        title: overflowedIndicator,
        disabled: allVisible,
        internalPopupClose: len === 0,
        popupClassName: overflowedIndicatorPopupClassName
      }, originOmitItems);
    },
    maxCount: internalMode !== 'horizontal' || disabledOverflow ? es/* default */.Z.INVALIDATE : es/* default */.Z.RESPONSIVE,
    ssr: "full",
    "data-menu-list": true,
    onVisibleChange: function onVisibleChange(newLastIndex) {
      setLastVisibleIndex(newLastIndex);
    },
    onKeyDown: onInternalKeyDown
  }, restProps));

  // >>>>> Render
  return /*#__PURE__*/react.createElement(context_PrivateContext.Provider, {
    value: privateContext
  }, /*#__PURE__*/react.createElement(IdContext.Provider, {
    value: uuid
  }, /*#__PURE__*/react.createElement(InheritableContextProvider, {
    prefixCls: prefixCls,
    rootClassName: rootClassName,
    mode: internalMode,
    openKeys: mergedOpenKeys,
    rtl: isRtl
    // Disabled
    ,
    disabled: disabled
    // Motion
    ,
    motion: mounted ? motion : null,
    defaultMotions: mounted ? defaultMotions : null
    // Active
    ,
    activeKey: mergedActiveKey,
    onActive: onActive,
    onInactive: onInactive
    // Selection
    ,
    selectedKeys: mergedSelectKeys
    // Level
    ,
    inlineIndent: inlineIndent
    // Popup
    ,
    subMenuOpenDelay: subMenuOpenDelay,
    subMenuCloseDelay: subMenuCloseDelay,
    forceSubMenuRender: forceSubMenuRender,
    builtinPlacements: builtinPlacements,
    triggerSubMenuAction: triggerSubMenuAction,
    getPopupContainer: getPopupContainer
    // Icon
    ,
    itemIcon: itemIcon,
    expandIcon: expandIcon
    // Events
    ,
    onItemClick: onInternalClick,
    onOpenChange: onInternalOpenChange
  }, /*#__PURE__*/react.createElement(PathUserContext.Provider, {
    value: pathUserContext
  }, container), /*#__PURE__*/react.createElement("div", {
    style: {
      display: 'none'
    },
    "aria-hidden": true
  }, /*#__PURE__*/react.createElement(PathRegisterContext.Provider, {
    value: registerPathContext
  }, measureChildList)))));
});
/* harmony default export */ var es_Menu = (Menu);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/index.js







var ExportMenu = es_Menu;
ExportMenu.Item = es_MenuItem;
ExportMenu.SubMenu = es_SubMenu;
ExportMenu.ItemGroup = es_MenuItemGroup;
ExportMenu.Divider = Divider;
/* harmony default export */ var rc_menu_es = (ExportMenu);//# sourceURL=[module]
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLFlBQVk7QUFDM0Isa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBLElBQUksa0JBQUc7QUFDUDtBQUNBLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFD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WTtBQUNRO0FBQ3BCO0FBRWxCO0FBQ2QsaUJBQWlCLE9BQUk7QUFDckIsa0JBQWtCLFdBQVE7QUFDMUIscUJBQXFCLFVBQU87QUFDNUIsdUJBQXVCLGdCQUFhO0FBQ3BDLHFCQUFxQixPQUFPO0FBQzVCLCtDQUFlLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy9jb250ZXh0L0lkQ29udGV4dC5qcz9lOGExIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYy1tZW51L2VzL2NvbnRleHQvTWVudUNvbnRleHQuanM/NzY3NSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy9jb250ZXh0L1BhdGhDb250ZXh0LmpzPzdmZjYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JjLW1lbnUvZXMvY29udGV4dC9Qcml2YXRlQ29udGV4dC5qcz8zMTZkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYy11dGlsL2VzL0RvbS9mb2N1cy5qcz9hZGU5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYy1tZW51L2VzL2hvb2tzL3VzZUFjY2Vzc2liaWxpdHkuanM/ZWZiMyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy91dGlscy90aW1lVXRpbC5qcz8wMDZhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYy1tZW51L2VzL2hvb2tzL3VzZUtleVJlY29yZHMuanM/MzA0MCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy9ob29rcy91c2VNZW1vQ2FsbGJhY2suanM/ZjAyMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy9ob29rcy91c2VVVUlELmpzP2RlNTMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JjLW1lbnUvZXMvaG9va3MvdXNlQWN0aXZlLmpzPzkyMGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JjLW1lbnUvZXMvaG9va3MvdXNlRGlyZWN0aW9uU3R5bGUuanM/YjBiYSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy9JY29uLmpzPzQ4MzYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JjLW1lbnUvZXMvdXRpbHMvd2FyblV0aWwuanM/YTFjNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy9NZW51SXRlbS5qcz80OTZmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYy1tZW51L2VzL1N1Yk1lbnUvU3ViTWVudUxpc3QuanM/MDhhYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy91dGlscy9jb21tb25VdGlsLmpzPzdiMzgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JjLW1lbnUvZXMvcGxhY2VtZW50cy5qcz8zYmE4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYy1tZW51L2VzL3V0aWxzL21vdGlvblV0aWwuanM/NjQ3NSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy9TdWJNZW51L1BvcHVwVHJpZ2dlci5qcz85YzQ4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYy1tZW51L2VzL1N1Yk1lbnUvSW5saW5lU3ViTWVudUxpc3QuanM/YzZiMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy9TdWJNZW51L2luZGV4LmpzP2M4YTYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JjLW1lbnUvZXMvRGl2aWRlci5qcz8zMjVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYy1tZW51L2VzL01lbnVJdGVtR3JvdXAuanM/YTViZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy91dGlscy9ub2RlVXRpbC5qcz8yMDdlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYy1tZW51L2VzL01lbnUuanM/M2ZjNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmMtbWVudS9lcy9pbmRleC5qcz85Yjg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCB2YXIgSWRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVudUlkKHV1aWQsIGV2ZW50S2V5KSB7XG4gIGlmICh1dWlkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gXCJcIi5jb25jYXQodXVpZCwgXCItXCIpLmNvbmNhdChldmVudEtleSk7XG59XG5cbi8qKlxuICogR2V0IGBkYXRhLW1lbnUtaWRgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW51SWQoZXZlbnRLZXkpIHtcbiAgdmFyIGlkID0gUmVhY3QudXNlQ29udGV4dChJZENvbnRleHQpO1xuICByZXR1cm4gZ2V0TWVudUlkKGlkLCBldmVudEtleSk7XG59IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyXCI7XG52YXIgX2V4Y2x1ZGVkID0gW1wiY2hpbGRyZW5cIiwgXCJsb2NrZWRcIl07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWVtbyBmcm9tIFwicmMtdXRpbC9lcy9ob29rcy91c2VNZW1vXCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwicmMtdXRpbC9lcy9pc0VxdWFsXCI7XG5leHBvcnQgdmFyIE1lbnVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiBtZXJnZVByb3BzKG9yaWdpbiwgdGFyZ2V0KSB7XG4gIHZhciBjbG9uZSA9IF9vYmplY3RTcHJlYWQoe30sIG9yaWdpbik7XG4gIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsb25lW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbmhlcml0YWJsZUNvbnRleHRQcm92aWRlcihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgbG9ja2VkID0gX3JlZi5sb2NrZWQsXG4gICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIHZhciBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChNZW51Q29udGV4dCk7XG4gIHZhciBpbmhlcml0YWJsZUNvbnRleHQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWVyZ2VQcm9wcyhjb250ZXh0LCByZXN0UHJvcHMpO1xuICB9LCBbY29udGV4dCwgcmVzdFByb3BzXSwgZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICByZXR1cm4gIWxvY2tlZCAmJiAocHJldlswXSAhPT0gbmV4dFswXSB8fCAhaXNFcXVhbChwcmV2WzFdLCBuZXh0WzFdLCB0cnVlKSk7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVudUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaW5oZXJpdGFibGVDb250ZXh0XG4gIH0sIGNoaWxkcmVuKTtcbn0iLCJpbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xudmFyIEVtcHR5TGlzdCA9IFtdO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09IFBhdGggUmVnaXN0ZXIgPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgdmFyIFBhdGhSZWdpc3RlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZWFzdXJlKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChQYXRoUmVnaXN0ZXJDb250ZXh0KTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBQYXRoIFRyYWNrZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT1cbmV4cG9ydCB2YXIgUGF0aFRyYWNrZXJDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoRW1wdHlMaXN0KTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VGdWxsUGF0aChldmVudEtleSkge1xuICB2YXIgcGFyZW50S2V5UGF0aCA9IFJlYWN0LnVzZUNvbnRleHQoUGF0aFRyYWNrZXJDb250ZXh0KTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBldmVudEtleSAhPT0gdW5kZWZpbmVkID8gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJlbnRLZXlQYXRoKSwgW2V2ZW50S2V5XSkgOiBwYXJlbnRLZXlQYXRoO1xuICB9LCBbcGFyZW50S2V5UGF0aCwgZXZlbnRLZXldKTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09IFBhdGggVXNlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IHZhciBQYXRoVXNlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG52YXIgUHJpdmF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG5leHBvcnQgZGVmYXVsdCBQcml2YXRlQ29udGV4dDsiLCJpbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xuaW1wb3J0IGlzVmlzaWJsZSBmcm9tIFwiLi9pc1Zpc2libGVcIjtcbmZ1bmN0aW9uIGZvY3VzYWJsZShub2RlKSB7XG4gIHZhciBpbmNsdWRlUG9zaXRpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICBpZiAoaXNWaXNpYmxlKG5vZGUpKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBpc0ZvY3VzYWJsZUVsZW1lbnQgPVxuICAgIC8vIEZvY3VzYWJsZSBlbGVtZW50XG4gICAgWydpbnB1dCcsICdzZWxlY3QnLCAndGV4dGFyZWEnLCAnYnV0dG9uJ10uaW5jbHVkZXMobm9kZU5hbWUpIHx8XG4gICAgLy8gRWRpdGFibGUgZWxlbWVudFxuICAgIG5vZGUuaXNDb250ZW50RWRpdGFibGUgfHxcbiAgICAvLyBBbmNob3Igd2l0aCBocmVmIGVsZW1lbnRcbiAgICBub2RlTmFtZSA9PT0gJ2EnICYmICEhbm9kZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblxuICAgIC8vIEdldCB0YWJJbmRleFxuICAgIHZhciB0YWJJbmRleEF0dHIgPSBub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB2YXIgdGFiSW5kZXhOdW0gPSBOdW1iZXIodGFiSW5kZXhBdHRyKTtcblxuICAgIC8vIFBhcnNlIGFzIG51bWJlciBpZiB2YWxpZGF0ZVxuICAgIHZhciB0YWJJbmRleCA9IG51bGw7XG4gICAgaWYgKHRhYkluZGV4QXR0ciAmJiAhTnVtYmVyLmlzTmFOKHRhYkluZGV4TnVtKSkge1xuICAgICAgdGFiSW5kZXggPSB0YWJJbmRleE51bTtcbiAgICB9IGVsc2UgaWYgKGlzRm9jdXNhYmxlRWxlbWVudCAmJiB0YWJJbmRleCA9PT0gbnVsbCkge1xuICAgICAgdGFiSW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8vIEJsb2NrIGZvY3VzYWJsZSBpZiBkaXNhYmxlZFxuICAgIGlmIChpc0ZvY3VzYWJsZUVsZW1lbnQgJiYgbm9kZS5kaXNhYmxlZCkge1xuICAgICAgdGFiSW5kZXggPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGFiSW5kZXggIT09IG51bGwgJiYgKHRhYkluZGV4ID49IDAgfHwgaW5jbHVkZVBvc2l0aXZlICYmIHRhYkluZGV4IDwgMCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvY3VzTm9kZUxpc3Qobm9kZSkge1xuICB2YXIgaW5jbHVkZVBvc2l0aXZlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIHJlcyA9IF90b0NvbnN1bWFibGVBcnJheShub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSkuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmb2N1c2FibGUoY2hpbGQsIGluY2x1ZGVQb3NpdGl2ZSk7XG4gIH0pO1xuICBpZiAoZm9jdXNhYmxlKG5vZGUsIGluY2x1ZGVQb3NpdGl2ZSkpIHtcbiAgICByZXMudW5zaGlmdChub2RlKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxudmFyIGxhc3RGb2N1c0VsZW1lbnQgPSBudWxsO1xuXG4vKiogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSBzaW5jZSB0aGlzIG1heSBmYWlsZWQgd2hlbiB1c2VkIGluIGFzeW5jICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUxhc3RGb2N1c05vZGUoKSB7XG4gIGxhc3RGb2N1c0VsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSBzaW5jZSB0aGlzIG1heSBmYWlsZWQgd2hlbiB1c2VkIGluIGFzeW5jICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJMYXN0Rm9jdXNOb2RlKCkge1xuICBsYXN0Rm9jdXNFbGVtZW50ID0gbnVsbDtcbn1cblxuLyoqIEBkZXByZWNhdGVkIERvIG5vdCB1c2Ugc2luY2UgdGhpcyBtYXkgZmFpbGVkIHdoZW4gdXNlZCBpbiBhc3luYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tMYXN0Rm9jdXNOb2RlKCkge1xuICBpZiAobGFzdEZvY3VzRWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICAvLyDlhYPntKDlj6/og73lt7Lnu4/ooqvnp7vliqjkuoZcbiAgICAgIGxhc3RGb2N1c0VsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBlbXB0eVxuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBsaW1pdFRhYlJhbmdlKG5vZGUsIGUpIHtcbiAgaWYgKGUua2V5Q29kZSA9PT0gOSkge1xuICAgIHZhciB0YWJOb2RlTGlzdCA9IGdldEZvY3VzTm9kZUxpc3Qobm9kZSk7XG4gICAgdmFyIGxhc3RUYWJOb2RlID0gdGFiTm9kZUxpc3RbZS5zaGlmdEtleSA/IDAgOiB0YWJOb2RlTGlzdC5sZW5ndGggLSAxXTtcbiAgICB2YXIgbGVhdmluZ1RhYiA9IGxhc3RUYWJOb2RlID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IG5vZGUgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGxlYXZpbmdUYWIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0YWJOb2RlTGlzdFtlLnNoaWZ0S2V5ID8gdGFiTm9kZUxpc3QubGVuZ3RoIC0gMSA6IDBdO1xuICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IGdldEZvY3VzTm9kZUxpc3QgfSBmcm9tIFwicmMtdXRpbC9lcy9Eb20vZm9jdXNcIjtcbmltcG9ydCBLZXlDb2RlIGZyb20gXCJyYy11dGlsL2VzL0tleUNvZGVcIjtcbmltcG9ydCByYWYgZnJvbSBcInJjLXV0aWwvZXMvcmFmXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZXRNZW51SWQgfSBmcm9tIFwiLi4vY29udGV4dC9JZENvbnRleHRcIjtcbi8vIGRlc3RydWN0IHRvIHJlZHVjZSBtaW5pZnkgc2l6ZVxudmFyIExFRlQgPSBLZXlDb2RlLkxFRlQsXG4gIFJJR0hUID0gS2V5Q29kZS5SSUdIVCxcbiAgVVAgPSBLZXlDb2RlLlVQLFxuICBET1dOID0gS2V5Q29kZS5ET1dOLFxuICBFTlRFUiA9IEtleUNvZGUuRU5URVIsXG4gIEVTQyA9IEtleUNvZGUuRVNDLFxuICBIT01FID0gS2V5Q29kZS5IT01FLFxuICBFTkQgPSBLZXlDb2RlLkVORDtcbnZhciBBcnJvd0tleXMgPSBbVVAsIERPV04sIExFRlQsIFJJR0hUXTtcbmZ1bmN0aW9uIGdldE9mZnNldChtb2RlLCBpc1Jvb3RMZXZlbCwgaXNSdGwsIHdoaWNoKSB7XG4gIHZhciBfb2Zmc2V0cztcbiAgdmFyIHByZXYgPSAncHJldic7XG4gIHZhciBuZXh0ID0gJ25leHQnO1xuICB2YXIgY2hpbGRyZW4gPSAnY2hpbGRyZW4nO1xuICB2YXIgcGFyZW50ID0gJ3BhcmVudCc7XG5cbiAgLy8gSW5saW5lIGVudGVyIGlzIHNwZWNpYWwgdGhhdCB3ZSB1c2UgdW5pcXVlIG9wZXJhdGlvblxuICBpZiAobW9kZSA9PT0gJ2lubGluZScgJiYgd2hpY2ggPT09IEVOVEVSKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlubGluZVRyaWdnZXI6IHRydWVcbiAgICB9O1xuICB9XG4gIHZhciBpbmxpbmUgPSBfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHt9LCBVUCwgcHJldiksIERPV04sIG5leHQpO1xuICB2YXIgaG9yaXpvbnRhbCA9IF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eSh7fSwgTEVGVCwgaXNSdGwgPyBuZXh0IDogcHJldiksIFJJR0hULCBpc1J0bCA/IHByZXYgOiBuZXh0KSwgRE9XTiwgY2hpbGRyZW4pLCBFTlRFUiwgY2hpbGRyZW4pO1xuICB2YXIgdmVydGljYWwgPSBfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eSh7fSwgVVAsIHByZXYpLCBET1dOLCBuZXh0KSwgRU5URVIsIGNoaWxkcmVuKSwgRVNDLCBwYXJlbnQpLCBMRUZULCBpc1J0bCA/IGNoaWxkcmVuIDogcGFyZW50KSwgUklHSFQsIGlzUnRsID8gcGFyZW50IDogY2hpbGRyZW4pO1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICBpbmxpbmU6IGlubGluZSxcbiAgICBob3Jpem9udGFsOiBob3Jpem9udGFsLFxuICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbCxcbiAgICBpbmxpbmVTdWI6IGlubGluZSxcbiAgICBob3Jpem9udGFsU3ViOiB2ZXJ0aWNhbCxcbiAgICB2ZXJ0aWNhbFN1YjogdmVydGljYWxcbiAgfTtcbiAgdmFyIHR5cGUgPSAoX29mZnNldHMgPSBvZmZzZXRzW1wiXCIuY29uY2F0KG1vZGUpLmNvbmNhdChpc1Jvb3RMZXZlbCA/ICcnIDogJ1N1YicpXSkgPT09IG51bGwgfHwgX29mZnNldHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vZmZzZXRzW3doaWNoXTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBwcmV2OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiAtMSxcbiAgICAgICAgc2libGluZzogdHJ1ZVxuICAgICAgfTtcbiAgICBjYXNlIG5leHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgIHNpYmxpbmc6IHRydWVcbiAgICAgIH07XG4gICAgY2FzZSBwYXJlbnQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IC0xLFxuICAgICAgICBzaWJsaW5nOiBmYWxzZVxuICAgICAgfTtcbiAgICBjYXNlIGNoaWxkcmVuOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICBzaWJsaW5nOiBmYWxzZVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRDb250YWluZXJVTChlbGVtZW50KSB7XG4gIHZhciBjdXJyZW50ID0gZWxlbWVudDtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBpZiAoY3VycmVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWVudS1saXN0JykpIHtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gTm9ybWFsbHkgc2hvdWxkIG5vdCByZWFjaCB0aGlzIGxpbmVcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZCBmb2N1c2VkIGVsZW1lbnQgd2l0aGluIGVsZW1lbnQgc2V0IHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIGdldEZvY3VzRWxlbWVudChhY3RpdmVFbGVtZW50LCBlbGVtZW50cykge1xuICB2YXIgY3VycmVudCA9IGFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBpZiAoZWxlbWVudHMuaGFzKGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gdGhlIGVsZW1lbnQgc2V0IHVuZGVyIHByb3ZpZGVkIGNvbnRhaW5lclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoY29udGFpbmVyLCBlbGVtZW50cykge1xuICB2YXIgbGlzdCA9IGdldEZvY3VzTm9kZUxpc3QoY29udGFpbmVyLCB0cnVlKTtcbiAgcmV0dXJuIGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICByZXR1cm4gZWxlbWVudHMuaGFzKGVsZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TmV4dEZvY3VzRWxlbWVudChwYXJlbnRRdWVyeUNvbnRhaW5lciwgZWxlbWVudHMsIGZvY3VzTWVudUVsZW1lbnQpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcbiAgLy8gS2V5IG9uIHRoZSBtZW51IGl0ZW0gd2lsbCBub3QgZ2V0IHZhbGlkYXRlIHBhcmVudCBjb250YWluZXJcbiAgaWYgKCFwYXJlbnRRdWVyeUNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTGlzdCBjdXJyZW50IGxldmVsIG1lbnUgaXRlbSBlbGVtZW50c1xuICB2YXIgc2FtZUxldmVsRm9jdXNhYmxlTWVudUVsZW1lbnRMaXN0ID0gZ2V0Rm9jdXNhYmxlRWxlbWVudHMocGFyZW50UXVlcnlDb250YWluZXIsIGVsZW1lbnRzKTtcblxuICAvLyBGaW5kIG5leHQgZm9jdXMgaW5kZXhcbiAgdmFyIGNvdW50ID0gc2FtZUxldmVsRm9jdXNhYmxlTWVudUVsZW1lbnRMaXN0Lmxlbmd0aDtcbiAgdmFyIGZvY3VzSW5kZXggPSBzYW1lTGV2ZWxGb2N1c2FibGVNZW51RWxlbWVudExpc3QuZmluZEluZGV4KGZ1bmN0aW9uIChlbGUpIHtcbiAgICByZXR1cm4gZm9jdXNNZW51RWxlbWVudCA9PT0gZWxlO1xuICB9KTtcbiAgaWYgKG9mZnNldCA8IDApIHtcbiAgICBpZiAoZm9jdXNJbmRleCA9PT0gLTEpIHtcbiAgICAgIGZvY3VzSW5kZXggPSBjb3VudCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvY3VzSW5kZXggLT0gMTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2Zmc2V0ID4gMCkge1xuICAgIGZvY3VzSW5kZXggKz0gMTtcbiAgfVxuICBmb2N1c0luZGV4ID0gKGZvY3VzSW5kZXggKyBjb3VudCkgJSBjb3VudDtcblxuICAvLyBGb2N1cyBtZW51IGl0ZW1cbiAgcmV0dXJuIHNhbWVMZXZlbEZvY3VzYWJsZU1lbnVFbGVtZW50TGlzdFtmb2N1c0luZGV4XTtcbn1cbmV4cG9ydCB2YXIgcmVmcmVzaEVsZW1lbnRzID0gZnVuY3Rpb24gcmVmcmVzaEVsZW1lbnRzKGtleXMsIGlkKSB7XG4gIHZhciBlbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgdmFyIGtleTJlbGVtZW50ID0gbmV3IE1hcCgpO1xuICB2YXIgZWxlbWVudDJrZXkgPSBuZXcgTWFwKCk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbWVudS1pZD0nXCIuY29uY2F0KGdldE1lbnVJZChpZCwga2V5KSwgXCInXVwiKSk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnRzLmFkZChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQya2V5LnNldChlbGVtZW50LCBrZXkpO1xuICAgICAga2V5MmVsZW1lbnQuc2V0KGtleSwgZWxlbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAga2V5MmVsZW1lbnQ6IGtleTJlbGVtZW50LFxuICAgIGVsZW1lbnQya2V5OiBlbGVtZW50MmtleVxuICB9O1xufTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VBY2Nlc3NpYmlsaXR5KG1vZGUsIGFjdGl2ZUtleSwgaXNSdGwsIGlkLCBjb250YWluZXJSZWYsIGdldEtleXMsIGdldEtleVBhdGgsIHRyaWdnZXJBY3RpdmVLZXksIHRyaWdnZXJBY2Nlc3NpYmlsaXR5T3Blbiwgb3JpZ2luT25LZXlEb3duKSB7XG4gIHZhciByYWZSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBhY3RpdmVSZWYuY3VycmVudCA9IGFjdGl2ZUtleTtcbiAgdmFyIGNsZWFuUmFmID0gZnVuY3Rpb24gY2xlYW5SYWYoKSB7XG4gICAgcmFmLmNhbmNlbChyYWZSZWYuY3VycmVudCk7XG4gIH07XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFuUmFmKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgd2hpY2ggPSBlLndoaWNoO1xuICAgIGlmIChbXS5jb25jYXQoQXJyb3dLZXlzLCBbRU5URVIsIEVTQywgSE9NRSwgRU5EXSkuaW5jbHVkZXMod2hpY2gpKSB7XG4gICAgICB2YXIga2V5cyA9IGdldEtleXMoKTtcbiAgICAgIHZhciByZWZyZXNoZWRFbGVtZW50cyA9IHJlZnJlc2hFbGVtZW50cyhrZXlzLCBpZCk7XG4gICAgICB2YXIgX3JlZnJlc2hlZEVsZW1lbnRzID0gcmVmcmVzaGVkRWxlbWVudHMsXG4gICAgICAgIGVsZW1lbnRzID0gX3JlZnJlc2hlZEVsZW1lbnRzLmVsZW1lbnRzLFxuICAgICAgICBrZXkyZWxlbWVudCA9IF9yZWZyZXNoZWRFbGVtZW50cy5rZXkyZWxlbWVudCxcbiAgICAgICAgZWxlbWVudDJrZXkgPSBfcmVmcmVzaGVkRWxlbWVudHMuZWxlbWVudDJrZXk7XG5cbiAgICAgIC8vIEZpcnN0IHdlIHNob3VsZCBmaW5kIGN1cnJlbnQgZm9jdXNlZCBNZW51SXRlbS9TdWJNZW51IGVsZW1lbnRcbiAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0ga2V5MmVsZW1lbnQuZ2V0KGFjdGl2ZUtleSk7XG4gICAgICB2YXIgZm9jdXNNZW51RWxlbWVudCA9IGdldEZvY3VzRWxlbWVudChhY3RpdmVFbGVtZW50LCBlbGVtZW50cyk7XG4gICAgICB2YXIgZm9jdXNNZW51S2V5ID0gZWxlbWVudDJrZXkuZ2V0KGZvY3VzTWVudUVsZW1lbnQpO1xuICAgICAgdmFyIG9mZnNldE9iaiA9IGdldE9mZnNldChtb2RlLCBnZXRLZXlQYXRoKGZvY3VzTWVudUtleSwgdHJ1ZSkubGVuZ3RoID09PSAxLCBpc1J0bCwgd2hpY2gpO1xuXG4gICAgICAvLyBTb21lIG1vZGUgZG8gbm90IGhhdmUgZnVsbHkgYXJyb3cgb3BlcmF0aW9uIGxpa2UgaW5saW5lXG4gICAgICBpZiAoIW9mZnNldE9iaiAmJiB3aGljaCAhPT0gSE9NRSAmJiB3aGljaCAhPT0gRU5EKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQXJyb3cgcHJldmVudCBkZWZhdWx0IHRvIGF2b2lkIHBhZ2Ugc2Nyb2xsXG4gICAgICBpZiAoQXJyb3dLZXlzLmluY2x1ZGVzKHdoaWNoKSB8fCBbSE9NRSwgRU5EXS5pbmNsdWRlcyh3aGljaCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIHRyeUZvY3VzID0gZnVuY3Rpb24gdHJ5Rm9jdXMobWVudUVsZW1lbnQpIHtcbiAgICAgICAgaWYgKG1lbnVFbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGZvY3VzVGFyZ2V0RWxlbWVudCA9IG1lbnVFbGVtZW50O1xuXG4gICAgICAgICAgLy8gRm9jdXMgdG8gbGluayBpbnN0ZWFkIG9mIG1lbnUgaXRlbSBpZiBwb3NzaWJsZVxuICAgICAgICAgIHZhciBsaW5rID0gbWVudUVsZW1lbnQucXVlcnlTZWxlY3RvcignYScpO1xuICAgICAgICAgIGlmIChsaW5rICE9PSBudWxsICYmIGxpbmsgIT09IHZvaWQgMCAmJiBsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB7XG4gICAgICAgICAgICBmb2N1c1RhcmdldEVsZW1lbnQgPSBsaW5rO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFyZ2V0S2V5ID0gZWxlbWVudDJrZXkuZ2V0KG1lbnVFbGVtZW50KTtcbiAgICAgICAgICB0cmlnZ2VyQWN0aXZlS2V5KHRhcmdldEtleSk7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEbyBub3QgYHVzZUVmZmVjdGAgaGVyZSBzaW5jZSBgdHJ5Rm9jdXNgIG1heSB0cmlnZ2VyIGFzeW5jXG4gICAgICAgICAgICogd2hpY2ggbWFrZXMgUmVhY3Qgc3luYyB1cGRhdGUgdGhlIGBhY3RpdmVLZXlgXG4gICAgICAgICAgICogdGhhdCBmb3JjZSByZW5kZXIgYmVmb3JlIGB1c2VSZWZgIHNldCB0aGUgbmV4dCBhY3RpdmVLZXlcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjbGVhblJhZigpO1xuICAgICAgICAgIHJhZlJlZi5jdXJyZW50ID0gcmFmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVSZWYuY3VycmVudCA9PT0gdGFyZ2V0S2V5KSB7XG4gICAgICAgICAgICAgIGZvY3VzVGFyZ2V0RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKFtIT01FLCBFTkRdLmluY2x1ZGVzKHdoaWNoKSB8fCBvZmZzZXRPYmouc2libGluZyB8fCAhZm9jdXNNZW51RWxlbWVudCkge1xuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PSBTaWJsaW5nID09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIC8vIEZpbmQgd2Fsa2FibGUgZm9jdXMgbWVudSBlbGVtZW50IGNvbnRhaW5lclxuICAgICAgICB2YXIgcGFyZW50UXVlcnlDb250YWluZXI7XG4gICAgICAgIGlmICghZm9jdXNNZW51RWxlbWVudCB8fCBtb2RlID09PSAnaW5saW5lJykge1xuICAgICAgICAgIHBhcmVudFF1ZXJ5Q29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50UXVlcnlDb250YWluZXIgPSBmaW5kQ29udGFpbmVyVUwoZm9jdXNNZW51RWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgbmV4dCBmb2N1cyBlbGVtZW50XG4gICAgICAgIHZhciB0YXJnZXRFbGVtZW50O1xuICAgICAgICB2YXIgZm9jdXNhYmxlRWxlbWVudHMgPSBnZXRGb2N1c2FibGVFbGVtZW50cyhwYXJlbnRRdWVyeUNvbnRhaW5lciwgZWxlbWVudHMpO1xuICAgICAgICBpZiAod2hpY2ggPT09IEhPTUUpIHtcbiAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gZm9jdXNhYmxlRWxlbWVudHNbMF07XG4gICAgICAgIH0gZWxzZSBpZiAod2hpY2ggPT09IEVORCkge1xuICAgICAgICAgIHRhcmdldEVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gZ2V0TmV4dEZvY3VzRWxlbWVudChwYXJlbnRRdWVyeUNvbnRhaW5lciwgZWxlbWVudHMsIGZvY3VzTWVudUVsZW1lbnQsIG9mZnNldE9iai5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvY3VzIG1lbnUgaXRlbVxuICAgICAgICB0cnlGb2N1cyh0YXJnZXRFbGVtZW50KTtcblxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PSBJbmxpbmVUcmlnZ2VyID09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldE9iai5pbmxpbmVUcmlnZ2VyKSB7XG4gICAgICAgIC8vIElubGluZSB0cmlnZ2VyIG5vIG5lZWQgc3dpdGNoIHRvIHN1YiBtZW51IGl0ZW1cbiAgICAgICAgdHJpZ2dlckFjY2Vzc2liaWxpdHlPcGVuKGZvY3VzTWVudUtleSk7XG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PSBMZXZlbCA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0T2JqLm9mZnNldCA+IDApIHtcbiAgICAgICAgdHJpZ2dlckFjY2Vzc2liaWxpdHlPcGVuKGZvY3VzTWVudUtleSwgdHJ1ZSk7XG4gICAgICAgIGNsZWFuUmFmKCk7XG4gICAgICAgIHJhZlJlZi5jdXJyZW50ID0gcmFmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBBc3luYyBzaG91bGQgcmVzeW5jIGVsZW1lbnRzXG4gICAgICAgICAgcmVmcmVzaGVkRWxlbWVudHMgPSByZWZyZXNoRWxlbWVudHMoa2V5cywgaWQpO1xuICAgICAgICAgIHZhciBjb250cm9sSWQgPSBmb2N1c01lbnVFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpO1xuICAgICAgICAgIHZhciBzdWJRdWVyeUNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRyb2xJZCk7XG5cbiAgICAgICAgICAvLyBHZXQgc3ViIGZvY3VzYWJsZSBtZW51IGl0ZW1cbiAgICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IGdldE5leHRGb2N1c0VsZW1lbnQoc3ViUXVlcnlDb250YWluZXIsIHJlZnJlc2hlZEVsZW1lbnRzLmVsZW1lbnRzKTtcblxuICAgICAgICAgIC8vIEZvY3VzIG1lbnUgaXRlbVxuICAgICAgICAgIHRyeUZvY3VzKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICB9LCA1KTtcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0T2JqLm9mZnNldCA8IDApIHtcbiAgICAgICAgdmFyIGtleVBhdGggPSBnZXRLZXlQYXRoKGZvY3VzTWVudUtleSwgdHJ1ZSk7XG4gICAgICAgIHZhciBwYXJlbnRLZXkgPSBrZXlQYXRoW2tleVBhdGgubGVuZ3RoIC0gMl07XG4gICAgICAgIHZhciBwYXJlbnRNZW51RWxlbWVudCA9IGtleTJlbGVtZW50LmdldChwYXJlbnRLZXkpO1xuXG4gICAgICAgIC8vIEZvY3VzIG1lbnUgaXRlbVxuICAgICAgICB0cmlnZ2VyQWNjZXNzaWJpbGl0eU9wZW4ocGFyZW50S2V5LCBmYWxzZSk7XG4gICAgICAgIHRyeUZvY3VzKHBhcmVudE1lbnVFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXNzIG9yaWdpbiBrZXkgZG93biBldmVudFxuICAgIG9yaWdpbk9uS2V5RG93biA9PT0gbnVsbCB8fCBvcmlnaW5PbktleURvd24gPT09IHZvaWQgMCB8fCBvcmlnaW5PbktleURvd24oZSk7XG4gIH07XG59IiwiZXhwb3J0IGZ1bmN0aW9uIG5leHRTbGljZShjYWxsYmFjaykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGNhbGxiYWNrKTtcbn0iLCJpbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSBcInJjLXV0aWwvZXMvd2FybmluZ1wiO1xuaW1wb3J0IHsgbmV4dFNsaWNlIH0gZnJvbSBcIi4uL3V0aWxzL3RpbWVVdGlsXCI7XG52YXIgUEFUSF9TUExJVCA9ICdfX1JDX1VUSUxfUEFUSF9TUExJVF9fJztcbnZhciBnZXRQYXRoU3RyID0gZnVuY3Rpb24gZ2V0UGF0aFN0cihrZXlQYXRoKSB7XG4gIHJldHVybiBrZXlQYXRoLmpvaW4oUEFUSF9TUExJVCk7XG59O1xudmFyIGdldFBhdGhLZXlzID0gZnVuY3Rpb24gZ2V0UGF0aEtleXMoa2V5UGF0aFN0cikge1xuICByZXR1cm4ga2V5UGF0aFN0ci5zcGxpdChQQVRIX1NQTElUKTtcbn07XG5leHBvcnQgdmFyIE9WRVJGTE9XX0tFWSA9ICdyYy1tZW51LW1vcmUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlS2V5UmVjb3JkcygpIHtcbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKHt9KSxcbiAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICBpbnRlcm5hbEZvcmNlVXBkYXRlID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcbiAgdmFyIGtleTJwYXRoUmVmID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gIHZhciBwYXRoMmtleVJlZiA9IHVzZVJlZihuZXcgTWFwKCkpO1xuICB2YXIgX1JlYWN0JHVzZVN0YXRlMyA9IFJlYWN0LnVzZVN0YXRlKFtdKSxcbiAgICBfUmVhY3QkdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlMywgMiksXG4gICAgb3ZlcmZsb3dLZXlzID0gX1JlYWN0JHVzZVN0YXRlNFswXSxcbiAgICBzZXRPdmVyZmxvd0tleXMgPSBfUmVhY3QkdXNlU3RhdGU0WzFdO1xuICB2YXIgdXBkYXRlUmVmID0gdXNlUmVmKDApO1xuICB2YXIgZGVzdHJveVJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciBmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgIGlmICghZGVzdHJveVJlZi5jdXJyZW50KSB7XG4gICAgICBpbnRlcm5hbEZvcmNlVXBkYXRlKHt9KTtcbiAgICB9XG4gIH07XG4gIHZhciByZWdpc3RlclBhdGggPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoa2V5LCBrZXlQYXRoKSB7XG4gICAgLy8gV2FybmluZyBmb3IgaW52YWxpZGF0ZSBvciBkdXBsaWNhdGVkIGBrZXlgXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5pbmcoIWtleTJwYXRoUmVmLmN1cnJlbnQuaGFzKGtleSksIFwiRHVwbGljYXRlZCBrZXkgJ1wiLmNvbmNhdChrZXksIFwiJyB1c2VkIGluIE1lbnUgYnkgcGF0aCBbXCIpLmNvbmNhdChrZXlQYXRoLmpvaW4oJyA+ICcpLCBcIl1cIikpO1xuICAgIH1cblxuICAgIC8vIEZpbGwgbWFwXG4gICAgdmFyIGNvbm5lY3RlZFBhdGggPSBnZXRQYXRoU3RyKGtleVBhdGgpO1xuICAgIHBhdGgya2V5UmVmLmN1cnJlbnQuc2V0KGNvbm5lY3RlZFBhdGgsIGtleSk7XG4gICAga2V5MnBhdGhSZWYuY3VycmVudC5zZXQoa2V5LCBjb25uZWN0ZWRQYXRoKTtcbiAgICB1cGRhdGVSZWYuY3VycmVudCArPSAxO1xuICAgIHZhciBpZCA9IHVwZGF0ZVJlZi5jdXJyZW50O1xuICAgIG5leHRTbGljZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaWQgPT09IHVwZGF0ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdmFyIHVucmVnaXN0ZXJQYXRoID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGtleSwga2V5UGF0aCkge1xuICAgIHZhciBjb25uZWN0ZWRQYXRoID0gZ2V0UGF0aFN0cihrZXlQYXRoKTtcbiAgICBwYXRoMmtleVJlZi5jdXJyZW50LmRlbGV0ZShjb25uZWN0ZWRQYXRoKTtcbiAgICBrZXkycGF0aFJlZi5jdXJyZW50LmRlbGV0ZShrZXkpO1xuICB9LCBbXSk7XG4gIHZhciByZWZyZXNoT3ZlcmZsb3dLZXlzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGtleXMpIHtcbiAgICBzZXRPdmVyZmxvd0tleXMoa2V5cyk7XG4gIH0sIFtdKTtcbiAgdmFyIGdldEtleVBhdGggPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnRLZXksIGluY2x1ZGVPdmVyZmxvdykge1xuICAgIHZhciBmdWxsUGF0aCA9IGtleTJwYXRoUmVmLmN1cnJlbnQuZ2V0KGV2ZW50S2V5KSB8fCAnJztcbiAgICB2YXIga2V5cyA9IGdldFBhdGhLZXlzKGZ1bGxQYXRoKTtcbiAgICBpZiAoaW5jbHVkZU92ZXJmbG93ICYmIG92ZXJmbG93S2V5cy5pbmNsdWRlcyhrZXlzWzBdKSkge1xuICAgICAga2V5cy51bnNoaWZ0KE9WRVJGTE9XX0tFWSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9LCBbb3ZlcmZsb3dLZXlzXSk7XG4gIHZhciBpc1N1YlBhdGhLZXkgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocGF0aEtleXMsIGV2ZW50S2V5KSB7XG4gICAgcmV0dXJuIHBhdGhLZXlzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gIT09IHVuZGVmaW5lZDtcbiAgICB9KS5zb21lKGZ1bmN0aW9uIChwYXRoS2V5KSB7XG4gICAgICB2YXIgcGF0aEtleUxpc3QgPSBnZXRLZXlQYXRoKHBhdGhLZXksIHRydWUpO1xuICAgICAgcmV0dXJuIHBhdGhLZXlMaXN0LmluY2x1ZGVzKGV2ZW50S2V5KTtcbiAgICB9KTtcbiAgfSwgW2dldEtleVBhdGhdKTtcbiAgdmFyIGdldEtleXMgPSBmdW5jdGlvbiBnZXRLZXlzKCkge1xuICAgIHZhciBrZXlzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleTJwYXRoUmVmLmN1cnJlbnQua2V5cygpKTtcbiAgICBpZiAob3ZlcmZsb3dLZXlzLmxlbmd0aCkge1xuICAgICAga2V5cy5wdXNoKE9WRVJGTE9XX0tFWSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIGN1cnJlbnQga2V5IHJlbGF0ZWQgY2hpbGQgcGF0aCBrZXlzXG4gICAqL1xuICB2YXIgZ2V0U3ViUGF0aEtleXMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNvbm5lY3RlZFBhdGggPSBcIlwiLmNvbmNhdChrZXkycGF0aFJlZi5jdXJyZW50LmdldChrZXkpKS5jb25jYXQoUEFUSF9TUExJVCk7XG4gICAgdmFyIHBhdGhLZXlzID0gbmV3IFNldCgpO1xuICAgIF90b0NvbnN1bWFibGVBcnJheShwYXRoMmtleVJlZi5jdXJyZW50LmtleXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocGF0aEtleSkge1xuICAgICAgaWYgKHBhdGhLZXkuc3RhcnRzV2l0aChjb25uZWN0ZWRQYXRoKSkge1xuICAgICAgICBwYXRoS2V5cy5hZGQocGF0aDJrZXlSZWYuY3VycmVudC5nZXQocGF0aEtleSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXRoS2V5cztcbiAgfSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXN0cm95UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBSZWdpc3RlclxuICAgIHJlZ2lzdGVyUGF0aDogcmVnaXN0ZXJQYXRoLFxuICAgIHVucmVnaXN0ZXJQYXRoOiB1bnJlZ2lzdGVyUGF0aCxcbiAgICByZWZyZXNoT3ZlcmZsb3dLZXlzOiByZWZyZXNoT3ZlcmZsb3dLZXlzLFxuICAgIC8vIFV0aWxcbiAgICBpc1N1YlBhdGhLZXk6IGlzU3ViUGF0aEtleSxcbiAgICBnZXRLZXlQYXRoOiBnZXRLZXlQYXRoLFxuICAgIGdldEtleXM6IGdldEtleXMsXG4gICAgZ2V0U3ViUGF0aEtleXM6IGdldFN1YlBhdGhLZXlzXG4gIH07XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENhY2hlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybiBzYW1lIHJlZiBpbnN0ZWFkLlxuICogVGhpcyBpcyB1c2VkIGZvciBjb250ZXh0IG9wdGltaXphdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTWVtb0NhbGxiYWNrKGZ1bmMpIHtcbiAgdmFyIGZ1blJlZiA9IFJlYWN0LnVzZVJlZihmdW5jKTtcbiAgZnVuUmVmLmN1cnJlbnQgPSBmdW5jO1xuICB2YXIgY2FsbGJhY2sgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9mdW5SZWYkY3VycmVudDtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiAoX2Z1blJlZiRjdXJyZW50ID0gZnVuUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9mdW5SZWYkY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Z1blJlZiRjdXJyZW50LmNhbGwuYXBwbHkoX2Z1blJlZiRjdXJyZW50LCBbZnVuUmVmXS5jb25jYXQoYXJncykpO1xuICB9LCBbXSk7XG4gIHJldHVybiBmdW5jID8gY2FsbGJhY2sgOiB1bmRlZmluZWQ7XG59IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlTWVyZ2VkU3RhdGUgZnJvbSBcInJjLXV0aWwvZXMvaG9va3MvdXNlTWVyZ2VkU3RhdGVcIjtcbnZhciB1bmlxdWVQcmVmaXggPSBNYXRoLnJhbmRvbSgpLnRvRml4ZWQoNSkudG9TdHJpbmcoKS5zbGljZSgyKTtcbnZhciBpbnRlcm5hbElkID0gMDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVVVSUQoaWQpIHtcbiAgdmFyIF91c2VNZXJnZWRTdGF0ZSA9IHVzZU1lcmdlZFN0YXRlKGlkLCB7XG4gICAgICB2YWx1ZTogaWRcbiAgICB9KSxcbiAgICBfdXNlTWVyZ2VkU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZU1lcmdlZFN0YXRlLCAyKSxcbiAgICB1dWlkID0gX3VzZU1lcmdlZFN0YXRlMlswXSxcbiAgICBzZXRVVUlEID0gX3VzZU1lcmdlZFN0YXRlMlsxXTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnRlcm5hbElkICs9IDE7XG4gICAgdmFyIG5ld0lkID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JyA/ICd0ZXN0JyA6IFwiXCIuY29uY2F0KHVuaXF1ZVByZWZpeCwgXCItXCIpLmNvbmNhdChpbnRlcm5hbElkKTtcbiAgICBzZXRVVUlEKFwicmMtbWVudS11dWlkLVwiLmNvbmNhdChuZXdJZCkpO1xuICB9LCBbXSk7XG4gIHJldHVybiB1dWlkO1xufSIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1lbnVDb250ZXh0IH0gZnJvbSBcIi4uL2NvbnRleHQvTWVudUNvbnRleHRcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUFjdGl2ZShldmVudEtleSwgZGlzYWJsZWQsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKSB7XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTWVudUNvbnRleHQpLFxuICAgIGFjdGl2ZUtleSA9IF9SZWFjdCR1c2VDb250ZXh0LmFjdGl2ZUtleSxcbiAgICBvbkFjdGl2ZSA9IF9SZWFjdCR1c2VDb250ZXh0Lm9uQWN0aXZlLFxuICAgIG9uSW5hY3RpdmUgPSBfUmVhY3QkdXNlQ29udGV4dC5vbkluYWN0aXZlO1xuICB2YXIgcmV0ID0ge1xuICAgIGFjdGl2ZTogYWN0aXZlS2V5ID09PSBldmVudEtleVxuICB9O1xuXG4gIC8vIFNraXAgd2hlbiBkaXNhYmxlZFxuICBpZiAoIWRpc2FibGVkKSB7XG4gICAgcmV0Lm9uTW91c2VFbnRlciA9IGZ1bmN0aW9uIChkb21FdmVudCkge1xuICAgICAgb25Nb3VzZUVudGVyID09PSBudWxsIHx8IG9uTW91c2VFbnRlciA9PT0gdm9pZCAwIHx8IG9uTW91c2VFbnRlcih7XG4gICAgICAgIGtleTogZXZlbnRLZXksXG4gICAgICAgIGRvbUV2ZW50OiBkb21FdmVudFxuICAgICAgfSk7XG4gICAgICBvbkFjdGl2ZShldmVudEtleSk7XG4gICAgfTtcbiAgICByZXQub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKGRvbUV2ZW50KSB7XG4gICAgICBvbk1vdXNlTGVhdmUgPT09IG51bGwgfHwgb25Nb3VzZUxlYXZlID09PSB2b2lkIDAgfHwgb25Nb3VzZUxlYXZlKHtcbiAgICAgICAga2V5OiBldmVudEtleSxcbiAgICAgICAgZG9tRXZlbnQ6IGRvbUV2ZW50XG4gICAgICB9KTtcbiAgICAgIG9uSW5hY3RpdmUoZXZlbnRLZXkpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn0iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNZW51Q29udGV4dCB9IGZyb20gXCIuLi9jb250ZXh0L01lbnVDb250ZXh0XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VEaXJlY3Rpb25TdHlsZShsZXZlbCkge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KE1lbnVDb250ZXh0KSxcbiAgICBtb2RlID0gX1JlYWN0JHVzZUNvbnRleHQubW9kZSxcbiAgICBydGwgPSBfUmVhY3QkdXNlQ29udGV4dC5ydGwsXG4gICAgaW5saW5lSW5kZW50ID0gX1JlYWN0JHVzZUNvbnRleHQuaW5saW5lSW5kZW50O1xuICBpZiAobW9kZSAhPT0gJ2lubGluZScpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGVuID0gbGV2ZWw7XG4gIHJldHVybiBydGwgPyB7XG4gICAgcGFkZGluZ1JpZ2h0OiBsZW4gKiBpbmxpbmVJbmRlbnRcbiAgfSA6IHtcbiAgICBwYWRkaW5nTGVmdDogbGVuICogaW5saW5lSW5kZW50XG4gIH07XG59IiwiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEljb24oX3JlZikge1xuICB2YXIgaWNvbiA9IF9yZWYuaWNvbixcbiAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgaWNvbk5vZGU7XG4gIGlmIChpY29uID09PSBudWxsIHx8IGljb24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBpY29uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWNvbk5vZGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChpY29uLCBfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpY29uICE9PSBcImJvb2xlYW5cIikge1xuICAgIC8vIENvbXBhdGlibGUgZm9yIG9yaWdpbiBkZWZpbml0aW9uXG4gICAgaWNvbk5vZGUgPSBpY29uO1xuICB9XG4gIHJldHVybiBpY29uTm9kZSB8fCBjaGlsZHJlbiB8fCBudWxsO1xufSIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG52YXIgX2V4Y2x1ZGVkID0gW1wiaXRlbVwiXTtcbmltcG9ydCB3YXJuaW5nIGZyb20gXCJyYy11dGlsL2VzL3dhcm5pbmdcIjtcblxuLyoqXG4gKiBgb25DbGlja2AgZXZlbnQgcmV0dXJuIGBpbmZvLml0ZW1gIHdoaWNoIHBvaW50IHRvIHJlYWN0IG5vZGUgZGlyZWN0bHkuXG4gKiBXZSBzaG91bGQgd2FybmluZyB0aGlzIHNpbmNlIGl0IHdpbGwgbm90IHdvcmsgb24gRkMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YXJuSXRlbVByb3AoX3JlZikge1xuICB2YXIgaXRlbSA9IF9yZWYuaXRlbSxcbiAgICByZXN0SW5mbyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdEluZm8sICdpdGVtJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2BpbmZvLml0ZW1gIGlzIGRlcHJlY2F0ZWQgc2luY2Ugd2Ugd2lsbCBtb3ZlIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IG5vdCBwcm92aWRlcyBSZWFjdCBOb2RlIGluc3RhbmNlIGluIGZ1dHVyZS4nKTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN0SW5mbztcbn0iLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDJcIjtcbmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5XCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfaW5oZXJpdHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzXCI7XG5pbXBvcnQgX2NyZWF0ZVN1cGVyIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVTdXBlclwiO1xudmFyIF9leGNsdWRlZCA9IFtcInRpdGxlXCIsIFwiYXR0cmlidXRlXCIsIFwiZWxlbWVudFJlZlwiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcInN0eWxlXCIsIFwiY2xhc3NOYW1lXCIsIFwiZXZlbnRLZXlcIiwgXCJ3YXJuS2V5XCIsIFwiZGlzYWJsZWRcIiwgXCJpdGVtSWNvblwiLCBcImNoaWxkcmVuXCIsIFwicm9sZVwiLCBcIm9uTW91c2VFbnRlclwiLCBcIm9uTW91c2VMZWF2ZVwiLCBcIm9uQ2xpY2tcIiwgXCJvbktleURvd25cIiwgXCJvbkZvY3VzXCJdLFxuICBfZXhjbHVkZWQzID0gW1wiYWN0aXZlXCJdO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgT3ZlcmZsb3cgZnJvbSAncmMtb3ZlcmZsb3cnO1xuaW1wb3J0IEtleUNvZGUgZnJvbSBcInJjLXV0aWwvZXMvS2V5Q29kZVwiO1xuaW1wb3J0IG9taXQgZnJvbSBcInJjLXV0aWwvZXMvb21pdFwiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZVJlZiB9IGZyb20gXCJyYy11dGlsL2VzL3JlZlwiO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSBcInJjLXV0aWwvZXMvd2FybmluZ1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTWVudUlkIH0gZnJvbSBcIi4vY29udGV4dC9JZENvbnRleHRcIjtcbmltcG9ydCB7IE1lbnVDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dC9NZW51Q29udGV4dFwiO1xuaW1wb3J0IHsgdXNlRnVsbFBhdGgsIHVzZU1lYXN1cmUgfSBmcm9tIFwiLi9jb250ZXh0L1BhdGhDb250ZXh0XCI7XG5pbXBvcnQgUHJpdmF0ZUNvbnRleHQgZnJvbSBcIi4vY29udGV4dC9Qcml2YXRlQ29udGV4dFwiO1xuaW1wb3J0IHVzZUFjdGl2ZSBmcm9tIFwiLi9ob29rcy91c2VBY3RpdmVcIjtcbmltcG9ydCB1c2VEaXJlY3Rpb25TdHlsZSBmcm9tIFwiLi9ob29rcy91c2VEaXJlY3Rpb25TdHlsZVwiO1xuaW1wb3J0IEljb24gZnJvbSBcIi4vSWNvblwiO1xuaW1wb3J0IHsgd2Fybkl0ZW1Qcm9wIH0gZnJvbSBcIi4vdXRpbHMvd2FyblV0aWxcIjtcbi8vIFNpbmNlIE1lbnUgZXZlbnQgcHJvdmlkZSB0aGUgYGluZm8uaXRlbWAgd2hpY2ggcG9pbnQgdG8gdGhlIE1lbnVJdGVtIG5vZGUgaW5zdGFuY2UuXG4vLyBXZSBoYXZlIHRvIHVzZSBjbGFzcyBjb21wb25lbnQgaGVyZS5cbi8vIFRoaXMgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBkb2MgJiBhcGkgaW4gZnV0dXJlLlxudmFyIExlZ2FjeU1lbnVJdGVtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhMZWdhY3lNZW51SXRlbSwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTGVnYWN5TWVudUl0ZW0pO1xuICBmdW5jdGlvbiBMZWdhY3lNZW51SXRlbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGVnYWN5TWVudUl0ZW0pO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTGVnYWN5TWVudUl0ZW0sIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICB0aXRsZSA9IF90aGlzJHByb3BzLnRpdGxlLFxuICAgICAgICBhdHRyaWJ1dGUgPSBfdGhpcyRwcm9wcy5hdHRyaWJ1dGUsXG4gICAgICAgIGVsZW1lbnRSZWYgPSBfdGhpcyRwcm9wcy5lbGVtZW50UmVmLFxuICAgICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMsIF9leGNsdWRlZCk7XG5cbiAgICAgIC8vIEhlcmUgdGhlIHByb3BzIGFyZSBldmVudHVhbGx5IHBhc3NlZCB0byB0aGUgRE9NIGVsZW1lbnQuXG4gICAgICAvLyBSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgbm9uLXN0YW5kYXJkIGF0dHJpYnV0ZXMuXG4gICAgICAvLyBUaGVyZWZvcmUsIHJlbW92ZSB0aGUgcHJvcHMgdGhhdCBpcyBub3QgdXNlZCBoZXJlLlxuICAgICAgLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vYW50LWRlc2lnbi9hbnQtZGVzaWduL2lzc3Vlcy80MTM5NVxuICAgICAgdmFyIHBhc3NlZFByb3BzID0gb21pdChyZXN0UHJvcHMsIFsnZXZlbnRLZXknLCAncG9wdXBDbGFzc05hbWUnLCAncG9wdXBPZmZzZXQnLCAnb25UaXRsZUNsaWNrJ10pO1xuICAgICAgd2FybmluZyghYXR0cmlidXRlLCAnYGF0dHJpYnV0ZWAgb2YgTWVudS5JdGVtIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBwYXNzIGF0dHJpYnV0ZSBkaXJlY3RseS4nKTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChPdmVyZmxvdy5JdGVtLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlLCB7XG4gICAgICAgIHRpdGxlOiB0eXBlb2YgdGl0bGUgPT09ICdzdHJpbmcnID8gdGl0bGUgOiB1bmRlZmluZWRcbiAgICAgIH0sIHBhc3NlZFByb3BzLCB7XG4gICAgICAgIHJlZjogZWxlbWVudFJlZlxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGVnYWN5TWVudUl0ZW07XG59KFJlYWN0LkNvbXBvbmVudCk7XG4vKipcbiAqIFJlYWwgTWVudSBJdGVtIGNvbXBvbmVudFxuICovXG52YXIgSW50ZXJuYWxNZW51SXRlbSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIHZhciBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICBldmVudEtleSA9IHByb3BzLmV2ZW50S2V5LFxuICAgIHdhcm5LZXkgPSBwcm9wcy53YXJuS2V5LFxuICAgIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgaXRlbUljb24gPSBwcm9wcy5pdGVtSWNvbixcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgIHJvbGUgPSBwcm9wcy5yb2xlLFxuICAgIG9uTW91c2VFbnRlciA9IHByb3BzLm9uTW91c2VFbnRlcixcbiAgICBvbk1vdXNlTGVhdmUgPSBwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgb25DbGljayA9IHByb3BzLm9uQ2xpY2ssXG4gICAgb25LZXlEb3duID0gcHJvcHMub25LZXlEb3duLFxuICAgIG9uRm9jdXMgPSBwcm9wcy5vbkZvY3VzLFxuICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkMik7XG4gIHZhciBkb21EYXRhSWQgPSB1c2VNZW51SWQoZXZlbnRLZXkpO1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KE1lbnVDb250ZXh0KSxcbiAgICBwcmVmaXhDbHMgPSBfUmVhY3QkdXNlQ29udGV4dC5wcmVmaXhDbHMsXG4gICAgb25JdGVtQ2xpY2sgPSBfUmVhY3QkdXNlQ29udGV4dC5vbkl0ZW1DbGljayxcbiAgICBjb250ZXh0RGlzYWJsZWQgPSBfUmVhY3QkdXNlQ29udGV4dC5kaXNhYmxlZCxcbiAgICBvdmVyZmxvd0Rpc2FibGVkID0gX1JlYWN0JHVzZUNvbnRleHQub3ZlcmZsb3dEaXNhYmxlZCxcbiAgICBjb250ZXh0SXRlbUljb24gPSBfUmVhY3QkdXNlQ29udGV4dC5pdGVtSWNvbixcbiAgICBzZWxlY3RlZEtleXMgPSBfUmVhY3QkdXNlQ29udGV4dC5zZWxlY3RlZEtleXMsXG4gICAgb25BY3RpdmUgPSBfUmVhY3QkdXNlQ29udGV4dC5vbkFjdGl2ZTtcbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0MiA9IFJlYWN0LnVzZUNvbnRleHQoUHJpdmF0ZUNvbnRleHQpLFxuICAgIF9pbnRlcm5hbFJlbmRlck1lbnVJdGVtID0gX1JlYWN0JHVzZUNvbnRleHQyLl9pbnRlcm5hbFJlbmRlck1lbnVJdGVtO1xuICB2YXIgaXRlbUNscyA9IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItaXRlbVwiKTtcbiAgdmFyIGxlZ2FjeU1lbnVJdGVtUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIHZhciBlbGVtZW50UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIHZhciBtZXJnZWREaXNhYmxlZCA9IGNvbnRleHREaXNhYmxlZCB8fCBkaXNhYmxlZDtcbiAgdmFyIG1lcmdlZEVsZVJlZiA9IHVzZUNvbXBvc2VSZWYocmVmLCBlbGVtZW50UmVmKTtcbiAgdmFyIGNvbm5lY3RlZEtleXMgPSB1c2VGdWxsUGF0aChldmVudEtleSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gV2FybiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuS2V5KSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ01lbnVJdGVtIHNob3VsZCBub3QgbGVhdmUgdW5kZWZpbmVkIGBrZXlgLicpO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gSW5mbyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgZ2V0RXZlbnRJbmZvID0gZnVuY3Rpb24gZ2V0RXZlbnRJbmZvKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBldmVudEtleSxcbiAgICAgIC8vIE5vdGU6IEZvciBsZWdhY3kgY29kZSBpcyByZXZlcnNlZCB3aGljaCBub3QgbGlrZSBvdGhlciBhbnRkIGNvbXBvbmVudFxuICAgICAga2V5UGF0aDogX3RvQ29uc3VtYWJsZUFycmF5KGNvbm5lY3RlZEtleXMpLnJldmVyc2UoKSxcbiAgICAgIGl0ZW06IGxlZ2FjeU1lbnVJdGVtUmVmLmN1cnJlbnQsXG4gICAgICBkb21FdmVudDogZVxuICAgIH07XG4gIH07XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gSWNvbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgbWVyZ2VkSXRlbUljb24gPSBpdGVtSWNvbiB8fCBjb250ZXh0SXRlbUljb247XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PSBBY3RpdmUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgX3VzZUFjdGl2ZSA9IHVzZUFjdGl2ZShldmVudEtleSwgbWVyZ2VkRGlzYWJsZWQsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKSxcbiAgICBhY3RpdmUgPSBfdXNlQWN0aXZlLmFjdGl2ZSxcbiAgICBhY3RpdmVQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdXNlQWN0aXZlLCBfZXhjbHVkZWQzKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09IFNlbGVjdCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkS2V5cy5pbmNsdWRlcyhldmVudEtleSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09IERpcmVjdGlvblN0eWxlID09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgZGlyZWN0aW9uU3R5bGUgPSB1c2VEaXJlY3Rpb25TdHlsZShjb25uZWN0ZWRLZXlzLmxlbmd0aCk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PSBFdmVudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgb25JbnRlcm5hbENsaWNrID0gZnVuY3Rpb24gb25JbnRlcm5hbENsaWNrKGUpIHtcbiAgICBpZiAobWVyZ2VkRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGluZm8gPSBnZXRFdmVudEluZm8oZSk7XG4gICAgb25DbGljayA9PT0gbnVsbCB8fCBvbkNsaWNrID09PSB2b2lkIDAgfHwgb25DbGljayh3YXJuSXRlbVByb3AoaW5mbykpO1xuICAgIG9uSXRlbUNsaWNrKGluZm8pO1xuICB9O1xuICB2YXIgb25JbnRlcm5hbEtleURvd24gPSBmdW5jdGlvbiBvbkludGVybmFsS2V5RG93bihlKSB7XG4gICAgb25LZXlEb3duID09PSBudWxsIHx8IG9uS2V5RG93biA9PT0gdm9pZCAwIHx8IG9uS2V5RG93bihlKTtcbiAgICBpZiAoZS53aGljaCA9PT0gS2V5Q29kZS5FTlRFUikge1xuICAgICAgdmFyIGluZm8gPSBnZXRFdmVudEluZm8oZSk7XG5cbiAgICAgIC8vIExlZ2FjeS4gS2V5IHdpbGwgYWxzbyB0cmlnZ2VyIGNsaWNrIGV2ZW50XG4gICAgICBvbkNsaWNrID09PSBudWxsIHx8IG9uQ2xpY2sgPT09IHZvaWQgMCB8fCBvbkNsaWNrKHdhcm5JdGVtUHJvcChpbmZvKSk7XG4gICAgICBvbkl0ZW1DbGljayhpbmZvKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZWQgZm9yIGFjY2Vzc2liaWxpdHkuIEhlbHBlciB3aWxsIGZvY3VzIGVsZW1lbnQgd2l0aG91dCBrZXkgYm9hcmQuXG4gICAqIFdlIHNob3VsZCBtYW51YWxseSB0cmlnZ2VyIGFuIGFjdGl2ZVxuICAgKi9cbiAgdmFyIG9uSW50ZXJuYWxGb2N1cyA9IGZ1bmN0aW9uIG9uSW50ZXJuYWxGb2N1cyhlKSB7XG4gICAgb25BY3RpdmUoZXZlbnRLZXkpO1xuICAgIG9uRm9jdXMgPT09IG51bGwgfHwgb25Gb2N1cyA9PT0gdm9pZCAwIHx8IG9uRm9jdXMoZSk7XG4gIH07XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PSBSZW5kZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgb3B0aW9uUm9sZVByb3BzID0ge307XG4gIGlmIChwcm9wcy5yb2xlID09PSAnb3B0aW9uJykge1xuICAgIG9wdGlvblJvbGVQcm9wc1snYXJpYS1zZWxlY3RlZCddID0gc2VsZWN0ZWQ7XG4gIH1cbiAgdmFyIHJlbmRlck5vZGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMZWdhY3lNZW51SXRlbSwgX2V4dGVuZHMoe1xuICAgIHJlZjogbGVnYWN5TWVudUl0ZW1SZWYsXG4gICAgZWxlbWVudFJlZjogbWVyZ2VkRWxlUmVmLFxuICAgIHJvbGU6IHJvbGUgPT09IG51bGwgPyAnbm9uZScgOiByb2xlIHx8ICdtZW51aXRlbScsXG4gICAgdGFiSW5kZXg6IGRpc2FibGVkID8gbnVsbCA6IC0xLFxuICAgIFwiZGF0YS1tZW51LWlkXCI6IG92ZXJmbG93RGlzYWJsZWQgJiYgZG9tRGF0YUlkID8gbnVsbCA6IGRvbURhdGFJZFxuICB9LCBvbWl0KHJlc3RQcm9wcywgWydleHRyYSddKSwgYWN0aXZlUHJvcHMsIG9wdGlvblJvbGVQcm9wcywge1xuICAgIGNvbXBvbmVudDogXCJsaVwiLFxuICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCxcbiAgICBzdHlsZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkaXJlY3Rpb25TdHlsZSksIHN0eWxlKSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoaXRlbUNscywgX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIFwiXCIuY29uY2F0KGl0ZW1DbHMsIFwiLWFjdGl2ZVwiKSwgYWN0aXZlKSwgXCJcIi5jb25jYXQoaXRlbUNscywgXCItc2VsZWN0ZWRcIiksIHNlbGVjdGVkKSwgXCJcIi5jb25jYXQoaXRlbUNscywgXCItZGlzYWJsZWRcIiksIG1lcmdlZERpc2FibGVkKSwgY2xhc3NOYW1lKSxcbiAgICBvbkNsaWNrOiBvbkludGVybmFsQ2xpY2ssXG4gICAgb25LZXlEb3duOiBvbkludGVybmFsS2V5RG93bixcbiAgICBvbkZvY3VzOiBvbkludGVybmFsRm9jdXNcbiAgfSksIGNoaWxkcmVuLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJY29uLCB7XG4gICAgcHJvcHM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgaXNTZWxlY3RlZDogc2VsZWN0ZWRcbiAgICB9KSxcbiAgICBpY29uOiBtZXJnZWRJdGVtSWNvblxuICB9KSk7XG4gIGlmIChfaW50ZXJuYWxSZW5kZXJNZW51SXRlbSkge1xuICAgIHJlbmRlck5vZGUgPSBfaW50ZXJuYWxSZW5kZXJNZW51SXRlbShyZW5kZXJOb2RlLCBwcm9wcywge1xuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlck5vZGU7XG59KTtcbmZ1bmN0aW9uIE1lbnVJdGVtKHByb3BzLCByZWYpIHtcbiAgdmFyIGV2ZW50S2V5ID0gcHJvcHMuZXZlbnRLZXk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gUmVjb3JkIEtleVBhdGggPT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIG1lYXN1cmUgPSB1c2VNZWFzdXJlKCk7XG4gIHZhciBjb25uZWN0ZWRLZXlQYXRoID0gdXNlRnVsbFBhdGgoZXZlbnRLZXkpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChtZWFzdXJlKSB7XG4gICAgICBtZWFzdXJlLnJlZ2lzdGVyUGF0aChldmVudEtleSwgY29ubmVjdGVkS2V5UGF0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZWFzdXJlLnVucmVnaXN0ZXJQYXRoKGV2ZW50S2V5LCBjb25uZWN0ZWRLZXlQYXRoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbY29ubmVjdGVkS2V5UGF0aF0pO1xuICBpZiAobWVhc3VyZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09IFJlbmRlciA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEludGVybmFsTWVudUl0ZW0sIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlZjogcmVmXG4gIH0pKTtcbn1cbmV4cG9ydCBkZWZhdWx0IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKE1lbnVJdGVtKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG52YXIgX2V4Y2x1ZGVkID0gW1wiY2xhc3NOYW1lXCIsIFwiY2hpbGRyZW5cIl07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IE1lbnVDb250ZXh0IH0gZnJvbSBcIi4uL2NvbnRleHQvTWVudUNvbnRleHRcIjtcbnZhciBJbnRlcm5hbFN1Yk1lbnVMaXN0ID0gZnVuY3Rpb24gSW50ZXJuYWxTdWJNZW51TGlzdChfcmVmLCByZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChNZW51Q29udGV4dCksXG4gICAgcHJlZml4Q2xzID0gX1JlYWN0JHVzZUNvbnRleHQucHJlZml4Q2xzLFxuICAgIG1vZGUgPSBfUmVhY3QkdXNlQ29udGV4dC5tb2RlLFxuICAgIHJ0bCA9IF9SZWFjdCR1c2VDb250ZXh0LnJ0bDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhwcmVmaXhDbHMsIHJ0bCAmJiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXJ0bFwiKSwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1zdWJcIiksIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItXCIpLmNvbmNhdChtb2RlID09PSAnaW5saW5lJyA/ICdpbmxpbmUnIDogJ3ZlcnRpY2FsJyksIGNsYXNzTmFtZSksXG4gICAgcm9sZTogXCJtZW51XCJcbiAgfSwgcmVzdFByb3BzLCB7XG4gICAgXCJkYXRhLW1lbnUtbGlzdFwiOiB0cnVlLFxuICAgIHJlZjogcmVmXG4gIH0pLCBjaGlsZHJlbik7XG59O1xudmFyIFN1Yk1lbnVMaXN0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoSW50ZXJuYWxTdWJNZW51TGlzdCk7XG5TdWJNZW51TGlzdC5kaXNwbGF5TmFtZSA9ICdTdWJNZW51TGlzdCc7XG5leHBvcnQgZGVmYXVsdCBTdWJNZW51TGlzdDsiLCJpbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xuaW1wb3J0IHRvQXJyYXkgZnJvbSBcInJjLXV0aWwvZXMvQ2hpbGRyZW4vdG9BcnJheVwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2hpbGRyZW4oY2hpbGRyZW4sIGtleVBhdGgpIHtcbiAgcmV0dXJuIHRvQXJyYXkoY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKCAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICB2YXIgX2V2ZW50S2V5LCBfY2hpbGQkcHJvcHM7XG4gICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgdmFyIGV2ZW50S2V5ID0gKF9ldmVudEtleSA9IChfY2hpbGQkcHJvcHMgPSBjaGlsZC5wcm9wcykgPT09IG51bGwgfHwgX2NoaWxkJHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2hpbGQkcHJvcHMuZXZlbnRLZXkpICE9PSBudWxsICYmIF9ldmVudEtleSAhPT0gdm9pZCAwID8gX2V2ZW50S2V5IDoga2V5O1xuICAgICAgdmFyIGVtcHR5S2V5ID0gZXZlbnRLZXkgPT09IG51bGwgfHwgZXZlbnRLZXkgPT09IHVuZGVmaW5lZDtcbiAgICAgIGlmIChlbXB0eUtleSkge1xuICAgICAgICBldmVudEtleSA9IFwidG1wX2tleS1cIi5jb25jYXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShrZXlQYXRoKSwgW2luZGV4XSkuam9pbignLScpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjbG9uZVByb3BzID0ge1xuICAgICAgICBrZXk6IGV2ZW50S2V5LFxuICAgICAgICBldmVudEtleTogZXZlbnRLZXlcbiAgICAgIH07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbXB0eUtleSkge1xuICAgICAgICBjbG9uZVByb3BzLndhcm5LZXkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNsb25lUHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pO1xufSIsInZhciBhdXRvQWRqdXN0T3ZlcmZsb3cgPSB7XG4gIGFkanVzdFg6IDEsXG4gIGFkanVzdFk6IDFcbn07XG5leHBvcnQgdmFyIHBsYWNlbWVudHMgPSB7XG4gIHRvcExlZnQ6IHtcbiAgICBwb2ludHM6IFsnYmwnLCAndGwnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93XG4gIH0sXG4gIHRvcFJpZ2h0OiB7XG4gICAgcG9pbnRzOiBbJ2JyJywgJ3RyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvd1xuICB9LFxuICBib3R0b21MZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ3RsJywgJ2JsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvd1xuICB9LFxuICBib3R0b21SaWdodDoge1xuICAgIHBvaW50czogWyd0cicsICdiciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3dcbiAgfSxcbiAgbGVmdFRvcDoge1xuICAgIHBvaW50czogWyd0cicsICd0bCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3dcbiAgfSxcbiAgbGVmdEJvdHRvbToge1xuICAgIHBvaW50czogWydicicsICdibCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3dcbiAgfSxcbiAgcmlnaHRUb3A6IHtcbiAgICBwb2ludHM6IFsndGwnLCAndHInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93XG4gIH0sXG4gIHJpZ2h0Qm90dG9tOiB7XG4gICAgcG9pbnRzOiBbJ2JsJywgJ2JyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvd1xuICB9XG59O1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzUnRsID0ge1xuICB0b3BMZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ2JsJywgJ3RsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvd1xuICB9LFxuICB0b3BSaWdodDoge1xuICAgIHBvaW50czogWydicicsICd0ciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3dcbiAgfSxcbiAgYm90dG9tTGVmdDoge1xuICAgIHBvaW50czogWyd0bCcsICdibCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3dcbiAgfSxcbiAgYm90dG9tUmlnaHQ6IHtcbiAgICBwb2ludHM6IFsndHInLCAnYnInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93XG4gIH0sXG4gIHJpZ2h0VG9wOiB7XG4gICAgcG9pbnRzOiBbJ3RyJywgJ3RsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvd1xuICB9LFxuICByaWdodEJvdHRvbToge1xuICAgIHBvaW50czogWydicicsICdibCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3dcbiAgfSxcbiAgbGVmdFRvcDoge1xuICAgIHBvaW50czogWyd0bCcsICd0ciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3dcbiAgfSxcbiAgbGVmdEJvdHRvbToge1xuICAgIHBvaW50czogWydibCcsICdiciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3dcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IHBsYWNlbWVudHM7IiwiZXhwb3J0IGZ1bmN0aW9uIGdldE1vdGlvbihtb2RlLCBtb3Rpb24sIGRlZmF1bHRNb3Rpb25zKSB7XG4gIGlmIChtb3Rpb24pIHtcbiAgICByZXR1cm4gbW90aW9uO1xuICB9XG4gIGlmIChkZWZhdWx0TW90aW9ucykge1xuICAgIHJldHVybiBkZWZhdWx0TW90aW9uc1ttb2RlXSB8fCBkZWZhdWx0TW90aW9ucy5vdGhlcjtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufSIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkMlwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVHJpZ2dlciBmcm9tICdAcmMtY29tcG9uZW50L3RyaWdnZXInO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgcmFmIGZyb20gXCJyYy11dGlsL2VzL3JhZlwiO1xuaW1wb3J0IHsgTWVudUNvbnRleHQgfSBmcm9tIFwiLi4vY29udGV4dC9NZW51Q29udGV4dFwiO1xuaW1wb3J0IHsgcGxhY2VtZW50cywgcGxhY2VtZW50c1J0bCB9IGZyb20gXCIuLi9wbGFjZW1lbnRzXCI7XG5pbXBvcnQgeyBnZXRNb3Rpb24gfSBmcm9tIFwiLi4vdXRpbHMvbW90aW9uVXRpbFwiO1xudmFyIHBvcHVwUGxhY2VtZW50TWFwID0ge1xuICBob3Jpem9udGFsOiAnYm90dG9tTGVmdCcsXG4gIHZlcnRpY2FsOiAncmlnaHRUb3AnLFxuICAndmVydGljYWwtbGVmdCc6ICdyaWdodFRvcCcsXG4gICd2ZXJ0aWNhbC1yaWdodCc6ICdsZWZ0VG9wJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvcHVwVHJpZ2dlcihfcmVmKSB7XG4gIHZhciBwcmVmaXhDbHMgPSBfcmVmLnByZWZpeENscyxcbiAgICB2aXNpYmxlID0gX3JlZi52aXNpYmxlLFxuICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICBwb3B1cCA9IF9yZWYucG9wdXAsXG4gICAgcG9wdXBTdHlsZSA9IF9yZWYucG9wdXBTdHlsZSxcbiAgICBwb3B1cENsYXNzTmFtZSA9IF9yZWYucG9wdXBDbGFzc05hbWUsXG4gICAgcG9wdXBPZmZzZXQgPSBfcmVmLnBvcHVwT2Zmc2V0LFxuICAgIGRpc2FibGVkID0gX3JlZi5kaXNhYmxlZCxcbiAgICBtb2RlID0gX3JlZi5tb2RlLFxuICAgIG9uVmlzaWJsZUNoYW5nZSA9IF9yZWYub25WaXNpYmxlQ2hhbmdlO1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KE1lbnVDb250ZXh0KSxcbiAgICBnZXRQb3B1cENvbnRhaW5lciA9IF9SZWFjdCR1c2VDb250ZXh0LmdldFBvcHVwQ29udGFpbmVyLFxuICAgIHJ0bCA9IF9SZWFjdCR1c2VDb250ZXh0LnJ0bCxcbiAgICBzdWJNZW51T3BlbkRlbGF5ID0gX1JlYWN0JHVzZUNvbnRleHQuc3ViTWVudU9wZW5EZWxheSxcbiAgICBzdWJNZW51Q2xvc2VEZWxheSA9IF9SZWFjdCR1c2VDb250ZXh0LnN1Yk1lbnVDbG9zZURlbGF5LFxuICAgIGJ1aWx0aW5QbGFjZW1lbnRzID0gX1JlYWN0JHVzZUNvbnRleHQuYnVpbHRpblBsYWNlbWVudHMsXG4gICAgdHJpZ2dlclN1Yk1lbnVBY3Rpb24gPSBfUmVhY3QkdXNlQ29udGV4dC50cmlnZ2VyU3ViTWVudUFjdGlvbixcbiAgICBmb3JjZVN1Yk1lbnVSZW5kZXIgPSBfUmVhY3QkdXNlQ29udGV4dC5mb3JjZVN1Yk1lbnVSZW5kZXIsXG4gICAgcm9vdENsYXNzTmFtZSA9IF9SZWFjdCR1c2VDb250ZXh0LnJvb3RDbGFzc05hbWUsXG4gICAgbW90aW9uID0gX1JlYWN0JHVzZUNvbnRleHQubW90aW9uLFxuICAgIGRlZmF1bHRNb3Rpb25zID0gX1JlYWN0JHVzZUNvbnRleHQuZGVmYXVsdE1vdGlvbnM7XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgaW5uZXJWaXNpYmxlID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICBzZXRJbm5lclZpc2libGUgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuICB2YXIgcGxhY2VtZW50ID0gcnRsID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwbGFjZW1lbnRzUnRsKSwgYnVpbHRpblBsYWNlbWVudHMpIDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwbGFjZW1lbnRzKSwgYnVpbHRpblBsYWNlbWVudHMpO1xuICB2YXIgcG9wdXBQbGFjZW1lbnQgPSBwb3B1cFBsYWNlbWVudE1hcFttb2RlXTtcbiAgdmFyIHRhcmdldE1vdGlvbiA9IGdldE1vdGlvbihtb2RlLCBtb3Rpb24sIGRlZmF1bHRNb3Rpb25zKTtcbiAgdmFyIHRhcmdldE1vdGlvblJlZiA9IFJlYWN0LnVzZVJlZih0YXJnZXRNb3Rpb24pO1xuICBpZiAobW9kZSAhPT0gJ2lubGluZScpIHtcbiAgICAvKipcbiAgICAgKiBQb3B1cFRyaWdnZXIgaXMgb25seSB1c2VkIGZvciB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCB0eXBlcy5cbiAgICAgKiBXaGVuIGNvbGxhcHNlZCBpcyB1bmZvbGRlZCwgdGhlIGlubGluZSBhbmltYXRpb24gd2lsbCBkZXN0cm95IHRoZSB2ZXJ0aWNhbCBhbmltYXRpb24uXG4gICAgICovXG4gICAgdGFyZ2V0TW90aW9uUmVmLmN1cnJlbnQgPSB0YXJnZXRNb3Rpb247XG4gIH1cbiAgdmFyIG1lcmdlZE1vdGlvbiA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGFyZ2V0TW90aW9uUmVmLmN1cnJlbnQpLCB7fSwge1xuICAgIGxlYXZlZENsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1oaWRkZW5cIiksXG4gICAgcmVtb3ZlT25MZWF2ZTogZmFsc2UsXG4gICAgbW90aW9uQXBwZWFyOiB0cnVlXG4gIH0pO1xuXG4gIC8vIERlbGF5IHRvIGNoYW5nZSB2aXNpYmxlXG4gIHZhciB2aXNpYmxlUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmlzaWJsZVJlZi5jdXJyZW50ID0gcmFmKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldElubmVyVmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmFmLmNhbmNlbCh2aXNpYmxlUmVmLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFt2aXNpYmxlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUcmlnZ2VyLCB7XG4gICAgcHJlZml4Q2xzOiBwcmVmaXhDbHMsXG4gICAgcG9wdXBDbGFzc05hbWU6IGNsYXNzTmFtZXMoXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1wb3B1cFwiKSwgX2RlZmluZVByb3BlcnR5KHt9LCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXJ0bFwiKSwgcnRsKSwgcG9wdXBDbGFzc05hbWUsIHJvb3RDbGFzc05hbWUpLFxuICAgIHN0cmV0Y2g6IG1vZGUgPT09ICdob3Jpem9udGFsJyA/ICdtaW5XaWR0aCcgOiBudWxsLFxuICAgIGdldFBvcHVwQ29udGFpbmVyOiBnZXRQb3B1cENvbnRhaW5lcixcbiAgICBidWlsdGluUGxhY2VtZW50czogcGxhY2VtZW50LFxuICAgIHBvcHVwUGxhY2VtZW50OiBwb3B1cFBsYWNlbWVudCxcbiAgICBwb3B1cFZpc2libGU6IGlubmVyVmlzaWJsZSxcbiAgICBwb3B1cDogcG9wdXAsXG4gICAgcG9wdXBTdHlsZTogcG9wdXBTdHlsZSxcbiAgICBwb3B1cEFsaWduOiBwb3B1cE9mZnNldCAmJiB7XG4gICAgICBvZmZzZXQ6IHBvcHVwT2Zmc2V0XG4gICAgfSxcbiAgICBhY3Rpb246IGRpc2FibGVkID8gW10gOiBbdHJpZ2dlclN1Yk1lbnVBY3Rpb25dLFxuICAgIG1vdXNlRW50ZXJEZWxheTogc3ViTWVudU9wZW5EZWxheSxcbiAgICBtb3VzZUxlYXZlRGVsYXk6IHN1Yk1lbnVDbG9zZURlbGF5LFxuICAgIG9uUG9wdXBWaXNpYmxlQ2hhbmdlOiBvblZpc2libGVDaGFuZ2UsXG4gICAgZm9yY2VSZW5kZXI6IGZvcmNlU3ViTWVudVJlbmRlcixcbiAgICBwb3B1cE1vdGlvbjogbWVyZ2VkTW90aW9uLFxuICAgIGZyZXNoOiB0cnVlXG4gIH0sIGNoaWxkcmVuKTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyXCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBDU1NNb3Rpb24gZnJvbSAncmMtbW90aW9uJztcbmltcG9ydCB7IGdldE1vdGlvbiB9IGZyb20gXCIuLi91dGlscy9tb3Rpb25VdGlsXCI7XG5pbXBvcnQgTWVudUNvbnRleHRQcm92aWRlciwgeyBNZW51Q29udGV4dCB9IGZyb20gXCIuLi9jb250ZXh0L01lbnVDb250ZXh0XCI7XG5pbXBvcnQgU3ViTWVudUxpc3QgZnJvbSBcIi4vU3ViTWVudUxpc3RcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIElubGluZVN1Yk1lbnVMaXN0KF9yZWYpIHtcbiAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICBvcGVuID0gX3JlZi5vcGVuLFxuICAgIGtleVBhdGggPSBfcmVmLmtleVBhdGgsXG4gICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgZml4ZWRNb2RlID0gJ2lubGluZSc7XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTWVudUNvbnRleHQpLFxuICAgIHByZWZpeENscyA9IF9SZWFjdCR1c2VDb250ZXh0LnByZWZpeENscyxcbiAgICBmb3JjZVN1Yk1lbnVSZW5kZXIgPSBfUmVhY3QkdXNlQ29udGV4dC5mb3JjZVN1Yk1lbnVSZW5kZXIsXG4gICAgbW90aW9uID0gX1JlYWN0JHVzZUNvbnRleHQubW90aW9uLFxuICAgIGRlZmF1bHRNb3Rpb25zID0gX1JlYWN0JHVzZUNvbnRleHQuZGVmYXVsdE1vdGlvbnMsXG4gICAgbW9kZSA9IF9SZWFjdCR1c2VDb250ZXh0Lm1vZGU7XG5cbiAgLy8gQWx3YXlzIHVzZSBsYXRlc3QgbW9kZSBjaGVja1xuICB2YXIgc2FtZU1vZGVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBzYW1lTW9kZVJlZi5jdXJyZW50ID0gbW9kZSA9PT0gZml4ZWRNb2RlO1xuXG4gIC8vIFdlIHJlY29yZCBgZGVzdHJveWAgbWFyayBoZXJlIHNpbmNlIHdoZW4gbW9kZSBjaGFuZ2UgZnJvbSBgaW5saW5lYCB0byBvdGhlcnMuXG4gIC8vIFRoZSBpbmxpbmUgbGlzdCBzaG91bGQgcmVtb3ZlIHdoZW4gbW90aW9uIGVuZC5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKCFzYW1lTW9kZVJlZi5jdXJyZW50KSxcbiAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICBkZXN0cm95ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICBzZXREZXN0cm95ID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcbiAgdmFyIG1lcmdlZE9wZW4gPSBzYW1lTW9kZVJlZi5jdXJyZW50ID8gb3BlbiA6IGZhbHNlO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBFZmZlY3QgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFJlc2V0IGRlc3Ryb3kgc3RhdGUgd2hlbiBtb2RlIGNoYW5nZSBiYWNrXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNhbWVNb2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgIHNldERlc3Ryb3koZmFsc2UpO1xuICAgIH1cbiAgfSwgW21vZGVdKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gUmVuZGVyID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgbWVyZ2VkTW90aW9uID0gX29iamVjdFNwcmVhZCh7fSwgZ2V0TW90aW9uKGZpeGVkTW9kZSwgbW90aW9uLCBkZWZhdWx0TW90aW9ucykpO1xuXG4gIC8vIE5vIG5lZWQgYXBwZWFyIHNpbmNlIG5lc3QgaW5saW5lQ29sbGFwc2UgY2hhbmdlZFxuICBpZiAoa2V5UGF0aC5sZW5ndGggPiAxKSB7XG4gICAgbWVyZ2VkTW90aW9uLm1vdGlvbkFwcGVhciA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSGlkZSBpbmxpbmUgbGlzdCB3aGVuIG1vZGUgY2hhbmdlZCBhbmQgbW90aW9uIGVuZFxuICB2YXIgb3JpZ2luT25WaXNpYmxlQ2hhbmdlZCA9IG1lcmdlZE1vdGlvbi5vblZpc2libGVDaGFuZ2VkO1xuICBtZXJnZWRNb3Rpb24ub25WaXNpYmxlQ2hhbmdlZCA9IGZ1bmN0aW9uIChuZXdWaXNpYmxlKSB7XG4gICAgaWYgKCFzYW1lTW9kZVJlZi5jdXJyZW50ICYmICFuZXdWaXNpYmxlKSB7XG4gICAgICBzZXREZXN0cm95KHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ2luT25WaXNpYmxlQ2hhbmdlZCA9PT0gbnVsbCB8fCBvcmlnaW5PblZpc2libGVDaGFuZ2VkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5PblZpc2libGVDaGFuZ2VkKG5ld1Zpc2libGUpO1xuICB9O1xuICBpZiAoZGVzdHJveSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW51Q29udGV4dFByb3ZpZGVyLCB7XG4gICAgbW9kZTogZml4ZWRNb2RlLFxuICAgIGxvY2tlZDogIXNhbWVNb2RlUmVmLmN1cnJlbnRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ1NTTW90aW9uLCBfZXh0ZW5kcyh7XG4gICAgdmlzaWJsZTogbWVyZ2VkT3BlblxuICB9LCBtZXJnZWRNb3Rpb24sIHtcbiAgICBmb3JjZVJlbmRlcjogZm9yY2VTdWJNZW51UmVuZGVyLFxuICAgIHJlbW92ZU9uTGVhdmU6IGZhbHNlLFxuICAgIGxlYXZlZENsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1oaWRkZW5cIilcbiAgfSksIGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciBtb3Rpb25DbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBtb3Rpb25TdHlsZSA9IF9yZWYyLnN0eWxlO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTdWJNZW51TGlzdCwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgY2xhc3NOYW1lOiBtb3Rpb25DbGFzc05hbWUsXG4gICAgICBzdHlsZTogbW90aW9uU3R5bGVcbiAgICB9LCBjaGlsZHJlbik7XG4gIH0pKTtcbn0iLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkMlwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xudmFyIF9leGNsdWRlZCA9IFtcInN0eWxlXCIsIFwiY2xhc3NOYW1lXCIsIFwidGl0bGVcIiwgXCJldmVudEtleVwiLCBcIndhcm5LZXlcIiwgXCJkaXNhYmxlZFwiLCBcImludGVybmFsUG9wdXBDbG9zZVwiLCBcImNoaWxkcmVuXCIsIFwiaXRlbUljb25cIiwgXCJleHBhbmRJY29uXCIsIFwicG9wdXBDbGFzc05hbWVcIiwgXCJwb3B1cE9mZnNldFwiLCBcInBvcHVwU3R5bGVcIiwgXCJvbkNsaWNrXCIsIFwib25Nb3VzZUVudGVyXCIsIFwib25Nb3VzZUxlYXZlXCIsIFwib25UaXRsZUNsaWNrXCIsIFwib25UaXRsZU1vdXNlRW50ZXJcIiwgXCJvblRpdGxlTW91c2VMZWF2ZVwiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImFjdGl2ZVwiXTtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IE92ZXJmbG93IGZyb20gJ3JjLW92ZXJmbG93JztcbmltcG9ydCB3YXJuaW5nIGZyb20gXCJyYy11dGlsL2VzL3dhcm5pbmdcIjtcbmltcG9ydCBTdWJNZW51TGlzdCBmcm9tIFwiLi9TdWJNZW51TGlzdFwiO1xuaW1wb3J0IHsgcGFyc2VDaGlsZHJlbiB9IGZyb20gXCIuLi91dGlscy9jb21tb25VdGlsXCI7XG5pbXBvcnQgTWVudUNvbnRleHRQcm92aWRlciwgeyBNZW51Q29udGV4dCB9IGZyb20gXCIuLi9jb250ZXh0L01lbnVDb250ZXh0XCI7XG5pbXBvcnQgdXNlTWVtb0NhbGxiYWNrIGZyb20gXCIuLi9ob29rcy91c2VNZW1vQ2FsbGJhY2tcIjtcbmltcG9ydCBQb3B1cFRyaWdnZXIgZnJvbSBcIi4vUG9wdXBUcmlnZ2VyXCI7XG5pbXBvcnQgSWNvbiBmcm9tIFwiLi4vSWNvblwiO1xuaW1wb3J0IHVzZUFjdGl2ZSBmcm9tIFwiLi4vaG9va3MvdXNlQWN0aXZlXCI7XG5pbXBvcnQgeyB3YXJuSXRlbVByb3AgfSBmcm9tIFwiLi4vdXRpbHMvd2FyblV0aWxcIjtcbmltcG9ydCB1c2VEaXJlY3Rpb25TdHlsZSBmcm9tIFwiLi4vaG9va3MvdXNlRGlyZWN0aW9uU3R5bGVcIjtcbmltcG9ydCBJbmxpbmVTdWJNZW51TGlzdCBmcm9tIFwiLi9JbmxpbmVTdWJNZW51TGlzdFwiO1xuaW1wb3J0IHsgUGF0aFRyYWNrZXJDb250ZXh0LCBQYXRoVXNlckNvbnRleHQsIHVzZUZ1bGxQYXRoLCB1c2VNZWFzdXJlIH0gZnJvbSBcIi4uL2NvbnRleHQvUGF0aENvbnRleHRcIjtcbmltcG9ydCB7IHVzZU1lbnVJZCB9IGZyb20gXCIuLi9jb250ZXh0L0lkQ29udGV4dFwiO1xuaW1wb3J0IFByaXZhdGVDb250ZXh0IGZyb20gXCIuLi9jb250ZXh0L1ByaXZhdGVDb250ZXh0XCI7XG52YXIgSW50ZXJuYWxTdWJNZW51ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgIHRpdGxlID0gcHJvcHMudGl0bGUsXG4gICAgZXZlbnRLZXkgPSBwcm9wcy5ldmVudEtleSxcbiAgICB3YXJuS2V5ID0gcHJvcHMud2FybktleSxcbiAgICBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLFxuICAgIGludGVybmFsUG9wdXBDbG9zZSA9IHByb3BzLmludGVybmFsUG9wdXBDbG9zZSxcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgIGl0ZW1JY29uID0gcHJvcHMuaXRlbUljb24sXG4gICAgZXhwYW5kSWNvbiA9IHByb3BzLmV4cGFuZEljb24sXG4gICAgcG9wdXBDbGFzc05hbWUgPSBwcm9wcy5wb3B1cENsYXNzTmFtZSxcbiAgICBwb3B1cE9mZnNldCA9IHByb3BzLnBvcHVwT2Zmc2V0LFxuICAgIHBvcHVwU3R5bGUgPSBwcm9wcy5wb3B1cFN0eWxlLFxuICAgIG9uQ2xpY2sgPSBwcm9wcy5vbkNsaWNrLFxuICAgIG9uTW91c2VFbnRlciA9IHByb3BzLm9uTW91c2VFbnRlcixcbiAgICBvbk1vdXNlTGVhdmUgPSBwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgb25UaXRsZUNsaWNrID0gcHJvcHMub25UaXRsZUNsaWNrLFxuICAgIG9uVGl0bGVNb3VzZUVudGVyID0gcHJvcHMub25UaXRsZU1vdXNlRW50ZXIsXG4gICAgb25UaXRsZU1vdXNlTGVhdmUgPSBwcm9wcy5vblRpdGxlTW91c2VMZWF2ZSxcbiAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XG4gIHZhciBkb21EYXRhSWQgPSB1c2VNZW51SWQoZXZlbnRLZXkpO1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KE1lbnVDb250ZXh0KSxcbiAgICBwcmVmaXhDbHMgPSBfUmVhY3QkdXNlQ29udGV4dC5wcmVmaXhDbHMsXG4gICAgbW9kZSA9IF9SZWFjdCR1c2VDb250ZXh0Lm1vZGUsXG4gICAgb3BlbktleXMgPSBfUmVhY3QkdXNlQ29udGV4dC5vcGVuS2V5cyxcbiAgICBjb250ZXh0RGlzYWJsZWQgPSBfUmVhY3QkdXNlQ29udGV4dC5kaXNhYmxlZCxcbiAgICBvdmVyZmxvd0Rpc2FibGVkID0gX1JlYWN0JHVzZUNvbnRleHQub3ZlcmZsb3dEaXNhYmxlZCxcbiAgICBhY3RpdmVLZXkgPSBfUmVhY3QkdXNlQ29udGV4dC5hY3RpdmVLZXksXG4gICAgc2VsZWN0ZWRLZXlzID0gX1JlYWN0JHVzZUNvbnRleHQuc2VsZWN0ZWRLZXlzLFxuICAgIGNvbnRleHRJdGVtSWNvbiA9IF9SZWFjdCR1c2VDb250ZXh0Lml0ZW1JY29uLFxuICAgIGNvbnRleHRFeHBhbmRJY29uID0gX1JlYWN0JHVzZUNvbnRleHQuZXhwYW5kSWNvbixcbiAgICBvbkl0ZW1DbGljayA9IF9SZWFjdCR1c2VDb250ZXh0Lm9uSXRlbUNsaWNrLFxuICAgIG9uT3BlbkNoYW5nZSA9IF9SZWFjdCR1c2VDb250ZXh0Lm9uT3BlbkNoYW5nZSxcbiAgICBvbkFjdGl2ZSA9IF9SZWFjdCR1c2VDb250ZXh0Lm9uQWN0aXZlO1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQyID0gUmVhY3QudXNlQ29udGV4dChQcml2YXRlQ29udGV4dCksXG4gICAgX2ludGVybmFsUmVuZGVyU3ViTWVudUl0ZW0gPSBfUmVhY3QkdXNlQ29udGV4dDIuX2ludGVybmFsUmVuZGVyU3ViTWVudUl0ZW07XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dDMgPSBSZWFjdC51c2VDb250ZXh0KFBhdGhVc2VyQ29udGV4dCksXG4gICAgaXNTdWJQYXRoS2V5ID0gX1JlYWN0JHVzZUNvbnRleHQzLmlzU3ViUGF0aEtleTtcbiAgdmFyIGNvbm5lY3RlZFBhdGggPSB1c2VGdWxsUGF0aCgpO1xuICB2YXIgc3ViTWVudVByZWZpeENscyA9IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItc3VibWVudVwiKTtcbiAgdmFyIG1lcmdlZERpc2FibGVkID0gY29udGV4dERpc2FibGVkIHx8IGRpc2FibGVkO1xuICB2YXIgZWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICB2YXIgcG9wdXBSZWYgPSBSZWFjdC51c2VSZWYoKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBXYXJuID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5LZXkpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnU3ViTWVudSBzaG91bGQgbm90IGxlYXZlIHVuZGVmaW5lZCBga2V5YC4nKTtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IEljb24gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIG1lcmdlZEl0ZW1JY29uID0gaXRlbUljb24gIT09IG51bGwgJiYgaXRlbUljb24gIT09IHZvaWQgMCA/IGl0ZW1JY29uIDogY29udGV4dEl0ZW1JY29uO1xuICB2YXIgbWVyZ2VkRXhwYW5kSWNvbiA9IGV4cGFuZEljb24gIT09IG51bGwgJiYgZXhwYW5kSWNvbiAhPT0gdm9pZCAwID8gZXhwYW5kSWNvbiA6IGNvbnRleHRFeHBhbmRJY29uO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IE9wZW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIG9yaWdpbk9wZW4gPSBvcGVuS2V5cy5pbmNsdWRlcyhldmVudEtleSk7XG4gIHZhciBvcGVuID0gIW92ZXJmbG93RGlzYWJsZWQgJiYgb3JpZ2luT3BlbjtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IFNlbGVjdCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBjaGlsZHJlblNlbGVjdGVkID0gaXNTdWJQYXRoS2V5KHNlbGVjdGVkS2V5cywgZXZlbnRLZXkpO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gQWN0aXZlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIF91c2VBY3RpdmUgPSB1c2VBY3RpdmUoZXZlbnRLZXksIG1lcmdlZERpc2FibGVkLCBvblRpdGxlTW91c2VFbnRlciwgb25UaXRsZU1vdXNlTGVhdmUpLFxuICAgIGFjdGl2ZSA9IF91c2VBY3RpdmUuYWN0aXZlLFxuICAgIGFjdGl2ZVByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF91c2VBY3RpdmUsIF9leGNsdWRlZDIpO1xuXG4gIC8vIEZhbGxiYWNrIG9mIGFjdGl2ZSBjaGVjayB0byBhdm9pZCBob3ZlciBvbiBtZW51IHRpdGxlIG9yIGRpc2FibGVkIGl0ZW1cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICBjaGlsZHJlbkFjdGl2ZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgc2V0Q2hpbGRyZW5BY3RpdmUgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuICB2YXIgdHJpZ2dlckNoaWxkcmVuQWN0aXZlID0gZnVuY3Rpb24gdHJpZ2dlckNoaWxkcmVuQWN0aXZlKG5ld0FjdGl2ZSkge1xuICAgIGlmICghbWVyZ2VkRGlzYWJsZWQpIHtcbiAgICAgIHNldENoaWxkcmVuQWN0aXZlKG5ld0FjdGl2ZSk7XG4gICAgfVxuICB9O1xuICB2YXIgb25JbnRlcm5hbE1vdXNlRW50ZXIgPSBmdW5jdGlvbiBvbkludGVybmFsTW91c2VFbnRlcihkb21FdmVudCkge1xuICAgIHRyaWdnZXJDaGlsZHJlbkFjdGl2ZSh0cnVlKTtcbiAgICBvbk1vdXNlRW50ZXIgPT09IG51bGwgfHwgb25Nb3VzZUVudGVyID09PSB2b2lkIDAgfHwgb25Nb3VzZUVudGVyKHtcbiAgICAgIGtleTogZXZlbnRLZXksXG4gICAgICBkb21FdmVudDogZG9tRXZlbnRcbiAgICB9KTtcbiAgfTtcbiAgdmFyIG9uSW50ZXJuYWxNb3VzZUxlYXZlID0gZnVuY3Rpb24gb25JbnRlcm5hbE1vdXNlTGVhdmUoZG9tRXZlbnQpIHtcbiAgICB0cmlnZ2VyQ2hpbGRyZW5BY3RpdmUoZmFsc2UpO1xuICAgIG9uTW91c2VMZWF2ZSA9PT0gbnVsbCB8fCBvbk1vdXNlTGVhdmUgPT09IHZvaWQgMCB8fCBvbk1vdXNlTGVhdmUoe1xuICAgICAga2V5OiBldmVudEtleSxcbiAgICAgIGRvbUV2ZW50OiBkb21FdmVudFxuICAgIH0pO1xuICB9O1xuICB2YXIgbWVyZ2VkQWN0aXZlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGFjdGl2ZTtcbiAgICB9XG4gICAgaWYgKG1vZGUgIT09ICdpbmxpbmUnKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5BY3RpdmUgfHwgaXNTdWJQYXRoS2V5KFthY3RpdmVLZXldLCBldmVudEtleSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgW21vZGUsIGFjdGl2ZSwgYWN0aXZlS2V5LCBjaGlsZHJlbkFjdGl2ZSwgZXZlbnRLZXksIGlzU3ViUGF0aEtleV0pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09IERpcmVjdGlvblN0eWxlID09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBkaXJlY3Rpb25TdHlsZSA9IHVzZURpcmVjdGlvblN0eWxlKGNvbm5lY3RlZFBhdGgubGVuZ3RoKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IEV2ZW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID4+Pj4gVGl0bGUgY2xpY2tcbiAgdmFyIG9uSW50ZXJuYWxUaXRsZUNsaWNrID0gZnVuY3Rpb24gb25JbnRlcm5hbFRpdGxlQ2xpY2soZSkge1xuICAgIC8vIFNraXAgaWYgZGlzYWJsZWRcbiAgICBpZiAobWVyZ2VkRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25UaXRsZUNsaWNrID09PSBudWxsIHx8IG9uVGl0bGVDbGljayA9PT0gdm9pZCAwIHx8IG9uVGl0bGVDbGljayh7XG4gICAgICBrZXk6IGV2ZW50S2V5LFxuICAgICAgZG9tRXZlbnQ6IGVcbiAgICB9KTtcblxuICAgIC8vIFRyaWdnZXIgb3BlbiBieSBjbGljayB3aGVuIG1vZGUgaXMgYGlubGluZWBcbiAgICBpZiAobW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIG9uT3BlbkNoYW5nZShldmVudEtleSwgIW9yaWdpbk9wZW4pO1xuICAgIH1cbiAgfTtcblxuICAvLyA+Pj4+IENvbnRleHQgZm9yIGNoaWxkcmVuIGNsaWNrXG4gIHZhciBvbk1lcmdlZEl0ZW1DbGljayA9IHVzZU1lbW9DYWxsYmFjayhmdW5jdGlvbiAoaW5mbykge1xuICAgIG9uQ2xpY2sgPT09IG51bGwgfHwgb25DbGljayA9PT0gdm9pZCAwIHx8IG9uQ2xpY2sod2Fybkl0ZW1Qcm9wKGluZm8pKTtcbiAgICBvbkl0ZW1DbGljayhpbmZvKTtcbiAgfSk7XG5cbiAgLy8gPj4+Pj4gVmlzaWJsZSBjaGFuZ2VcbiAgdmFyIG9uUG9wdXBWaXNpYmxlQ2hhbmdlID0gZnVuY3Rpb24gb25Qb3B1cFZpc2libGVDaGFuZ2UobmV3VmlzaWJsZSkge1xuICAgIGlmIChtb2RlICE9PSAnaW5saW5lJykge1xuICAgICAgb25PcGVuQ2hhbmdlKGV2ZW50S2V5LCBuZXdWaXNpYmxlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZWQgZm9yIGFjY2Vzc2liaWxpdHkuIEhlbHBlciB3aWxsIGZvY3VzIGVsZW1lbnQgd2l0aG91dCBrZXkgYm9hcmQuXG4gICAqIFdlIHNob3VsZCBtYW51YWxseSB0cmlnZ2VyIGFuIGFjdGl2ZVxuICAgKi9cbiAgdmFyIG9uSW50ZXJuYWxGb2N1cyA9IGZ1bmN0aW9uIG9uSW50ZXJuYWxGb2N1cygpIHtcbiAgICBvbkFjdGl2ZShldmVudEtleSk7XG4gIH07XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBSZW5kZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgcG9wdXBJZCA9IGRvbURhdGFJZCAmJiBcIlwiLmNvbmNhdChkb21EYXRhSWQsIFwiLXBvcHVwXCIpO1xuXG4gIC8vID4+Pj4+IFRpdGxlXG4gIHZhciB0aXRsZU5vZGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcm9sZTogXCJtZW51aXRlbVwiLFxuICAgIHN0eWxlOiBkaXJlY3Rpb25TdHlsZSxcbiAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHN1Yk1lbnVQcmVmaXhDbHMsIFwiLXRpdGxlXCIpLFxuICAgIHRhYkluZGV4OiBtZXJnZWREaXNhYmxlZCA/IG51bGwgOiAtMSxcbiAgICByZWY6IGVsZW1lbnRSZWYsXG4gICAgdGl0bGU6IHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycgPyB0aXRsZSA6IG51bGwsXG4gICAgXCJkYXRhLW1lbnUtaWRcIjogb3ZlcmZsb3dEaXNhYmxlZCAmJiBkb21EYXRhSWQgPyBudWxsIDogZG9tRGF0YUlkLFxuICAgIFwiYXJpYS1leHBhbmRlZFwiOiBvcGVuLFxuICAgIFwiYXJpYS1oYXNwb3B1cFwiOiB0cnVlLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiBwb3B1cElkLFxuICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBtZXJnZWREaXNhYmxlZCxcbiAgICBvbkNsaWNrOiBvbkludGVybmFsVGl0bGVDbGljayxcbiAgICBvbkZvY3VzOiBvbkludGVybmFsRm9jdXNcbiAgfSwgYWN0aXZlUHJvcHMpLCB0aXRsZSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgIGljb246IG1vZGUgIT09ICdob3Jpem9udGFsJyA/IG1lcmdlZEV4cGFuZEljb24gOiB1bmRlZmluZWQsXG4gICAgcHJvcHM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgaXNPcGVuOiBvcGVuLFxuICAgICAgLy8gW0xlZ2FjeV0gTm90IHN1cmUgd2h5IG5lZWQgdGhpcyBtYXJrXG4gICAgICBpc1N1Yk1lbnU6IHRydWVcbiAgICB9KVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImlcIiwge1xuICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQoc3ViTWVudVByZWZpeENscywgXCItYXJyb3dcIilcbiAgfSkpKTtcblxuICAvLyBDYWNoZSBtb2RlIGlmIGl0IGNoYW5nZSB0byBgaW5saW5lYCB3aGljaCBkbyBub3QgaGF2ZSBwb3B1cCBtb3Rpb25cbiAgdmFyIHRyaWdnZXJNb2RlUmVmID0gUmVhY3QudXNlUmVmKG1vZGUpO1xuICBpZiAobW9kZSAhPT0gJ2lubGluZScgJiYgY29ubmVjdGVkUGF0aC5sZW5ndGggPiAxKSB7XG4gICAgdHJpZ2dlck1vZGVSZWYuY3VycmVudCA9ICd2ZXJ0aWNhbCc7XG4gIH0gZWxzZSB7XG4gICAgdHJpZ2dlck1vZGVSZWYuY3VycmVudCA9IG1vZGU7XG4gIH1cbiAgaWYgKCFvdmVyZmxvd0Rpc2FibGVkKSB7XG4gICAgdmFyIHRyaWdnZXJNb2RlID0gdHJpZ2dlck1vZGVSZWYuY3VycmVudDtcblxuICAgIC8vIFN0aWxsIHdyYXAgd2l0aCBUcmlnZ2VyIGhlcmUgc2luY2Ugd2UgbmVlZCBhdm9pZCByZWFjdCByZS1tb3VudCBkb20gbm9kZVxuICAgIC8vIFdoaWNoIG1ha2VzIG1vdGlvbiBmYWlsZWRcbiAgICB0aXRsZU5vZGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb3B1cFRyaWdnZXIsIHtcbiAgICAgIG1vZGU6IHRyaWdnZXJNb2RlLFxuICAgICAgcHJlZml4Q2xzOiBzdWJNZW51UHJlZml4Q2xzLFxuICAgICAgdmlzaWJsZTogIWludGVybmFsUG9wdXBDbG9zZSAmJiBvcGVuICYmIG1vZGUgIT09ICdpbmxpbmUnLFxuICAgICAgcG9wdXBDbGFzc05hbWU6IHBvcHVwQ2xhc3NOYW1lLFxuICAgICAgcG9wdXBPZmZzZXQ6IHBvcHVwT2Zmc2V0LFxuICAgICAgcG9wdXBTdHlsZTogcG9wdXBTdHlsZSxcbiAgICAgIHBvcHVwOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW51Q29udGV4dFByb3ZpZGVyXG4gICAgICAvLyBTcGVjaWFsIGhhbmRsZSBvZiBob3Jpem9udGFsIG1vZGVcbiAgICAgICwge1xuICAgICAgICBtb2RlOiB0cmlnZ2VyTW9kZSA9PT0gJ2hvcml6b250YWwnID8gJ3ZlcnRpY2FsJyA6IHRyaWdnZXJNb2RlXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTdWJNZW51TGlzdCwge1xuICAgICAgICBpZDogcG9wdXBJZCxcbiAgICAgICAgcmVmOiBwb3B1cFJlZlxuICAgICAgfSwgY2hpbGRyZW4pKSxcbiAgICAgIGRpc2FibGVkOiBtZXJnZWREaXNhYmxlZCxcbiAgICAgIG9uVmlzaWJsZUNoYW5nZTogb25Qb3B1cFZpc2libGVDaGFuZ2VcbiAgICB9LCB0aXRsZU5vZGUpO1xuICB9XG5cbiAgLy8gPj4+Pj4gTGlzdCBub2RlXG4gIHZhciBsaXN0Tm9kZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJmbG93Lkl0ZW0sIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICByb2xlOiBcIm5vbmVcIlxuICB9LCByZXN0UHJvcHMsIHtcbiAgICBjb21wb25lbnQ6IFwibGlcIixcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN1Yk1lbnVQcmVmaXhDbHMsIFwiXCIuY29uY2F0KHN1Yk1lbnVQcmVmaXhDbHMsIFwiLVwiKS5jb25jYXQobW9kZSksIGNsYXNzTmFtZSwgX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHt9LCBcIlwiLmNvbmNhdChzdWJNZW51UHJlZml4Q2xzLCBcIi1vcGVuXCIpLCBvcGVuKSwgXCJcIi5jb25jYXQoc3ViTWVudVByZWZpeENscywgXCItYWN0aXZlXCIpLCBtZXJnZWRBY3RpdmUpLCBcIlwiLmNvbmNhdChzdWJNZW51UHJlZml4Q2xzLCBcIi1zZWxlY3RlZFwiKSwgY2hpbGRyZW5TZWxlY3RlZCksIFwiXCIuY29uY2F0KHN1Yk1lbnVQcmVmaXhDbHMsIFwiLWRpc2FibGVkXCIpLCBtZXJnZWREaXNhYmxlZCkpLFxuICAgIG9uTW91c2VFbnRlcjogb25JbnRlcm5hbE1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlOiBvbkludGVybmFsTW91c2VMZWF2ZVxuICB9KSwgdGl0bGVOb2RlLCAhb3ZlcmZsb3dEaXNhYmxlZCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbmxpbmVTdWJNZW51TGlzdCwge1xuICAgIGlkOiBwb3B1cElkLFxuICAgIG9wZW46IG9wZW4sXG4gICAga2V5UGF0aDogY29ubmVjdGVkUGF0aFxuICB9LCBjaGlsZHJlbikpO1xuICBpZiAoX2ludGVybmFsUmVuZGVyU3ViTWVudUl0ZW0pIHtcbiAgICBsaXN0Tm9kZSA9IF9pbnRlcm5hbFJlbmRlclN1Yk1lbnVJdGVtKGxpc3ROb2RlLCBwcm9wcywge1xuICAgICAgc2VsZWN0ZWQ6IGNoaWxkcmVuU2VsZWN0ZWQsXG4gICAgICBhY3RpdmU6IG1lcmdlZEFjdGl2ZSxcbiAgICAgIG9wZW46IG9wZW4sXG4gICAgICBkaXNhYmxlZDogbWVyZ2VkRGlzYWJsZWRcbiAgICB9KTtcbiAgfVxuXG4gIC8vID4+Pj4+IFJlbmRlclxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVudUNvbnRleHRQcm92aWRlciwge1xuICAgIG9uSXRlbUNsaWNrOiBvbk1lcmdlZEl0ZW1DbGljayxcbiAgICBtb2RlOiBtb2RlID09PSAnaG9yaXpvbnRhbCcgPyAndmVydGljYWwnIDogbW9kZSxcbiAgICBpdGVtSWNvbjogbWVyZ2VkSXRlbUljb24sXG4gICAgZXhwYW5kSWNvbjogbWVyZ2VkRXhwYW5kSWNvblxuICB9LCBsaXN0Tm9kZSk7XG59KTtcbnZhciBTdWJNZW51ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIGV2ZW50S2V5ID0gcHJvcHMuZXZlbnRLZXksXG4gICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGNvbm5lY3RlZEtleVBhdGggPSB1c2VGdWxsUGF0aChldmVudEtleSk7XG4gIHZhciBjaGlsZExpc3QgPSBwYXJzZUNoaWxkcmVuKGNoaWxkcmVuLCBjb25uZWN0ZWRLZXlQYXRoKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBSZWNvcmQgS2V5UGF0aCA9PT09PT09PT09PT09PT09PT09PVxuICB2YXIgbWVhc3VyZSA9IHVzZU1lYXN1cmUoKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobWVhc3VyZSkge1xuICAgICAgbWVhc3VyZS5yZWdpc3RlclBhdGgoZXZlbnRLZXksIGNvbm5lY3RlZEtleVBhdGgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWVhc3VyZS51bnJlZ2lzdGVyUGF0aChldmVudEtleSwgY29ubmVjdGVkS2V5UGF0aCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2Nvbm5lY3RlZEtleVBhdGhdKTtcbiAgdmFyIHJlbmRlck5vZGU7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09IFJlbmRlciA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgaWYgKG1lYXN1cmUpIHtcbiAgICByZW5kZXJOb2RlID0gY2hpbGRMaXN0O1xuICB9IGVsc2Uge1xuICAgIHJlbmRlck5vZGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnRlcm5hbFN1Yk1lbnUsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogcmVmXG4gICAgfSwgcHJvcHMpLCBjaGlsZExpc3QpO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQYXRoVHJhY2tlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29ubmVjdGVkS2V5UGF0aFxuICB9LCByZW5kZXJOb2RlKTtcbn0pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgU3ViTWVudS5kaXNwbGF5TmFtZSA9ICdTdWJNZW51Jztcbn1cbmV4cG9ydCBkZWZhdWx0IFN1Yk1lbnU7IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBNZW51Q29udGV4dCB9IGZyb20gXCIuL2NvbnRleHQvTWVudUNvbnRleHRcIjtcbmltcG9ydCB7IHVzZU1lYXN1cmUgfSBmcm9tIFwiLi9jb250ZXh0L1BhdGhDb250ZXh0XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEaXZpZGVyKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgIHN0eWxlID0gX3JlZi5zdHlsZTtcbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChNZW51Q29udGV4dCksXG4gICAgcHJlZml4Q2xzID0gX1JlYWN0JHVzZUNvbnRleHQucHJlZml4Q2xzO1xuICB2YXIgbWVhc3VyZSA9IHVzZU1lYXN1cmUoKTtcbiAgaWYgKG1lYXN1cmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7XG4gICAgcm9sZTogXCJzZXBhcmF0b3JcIixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1pdGVtLWRpdmlkZXJcIiksIGNsYXNzTmFtZSksXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0pO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbnZhciBfZXhjbHVkZWQgPSBbXCJjbGFzc05hbWVcIiwgXCJ0aXRsZVwiLCBcImV2ZW50S2V5XCIsIFwiY2hpbGRyZW5cIl07XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBvbWl0IGZyb20gXCJyYy11dGlsL2VzL29taXRcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1lbnVDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dC9NZW51Q29udGV4dFwiO1xuaW1wb3J0IHsgdXNlRnVsbFBhdGgsIHVzZU1lYXN1cmUgfSBmcm9tIFwiLi9jb250ZXh0L1BhdGhDb250ZXh0XCI7XG5pbXBvcnQgeyBwYXJzZUNoaWxkcmVuIH0gZnJvbSBcIi4vdXRpbHMvY29tbW9uVXRpbFwiO1xudmFyIEludGVybmFsTWVudUl0ZW1Hcm91cCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgdGl0bGUgPSBwcm9wcy50aXRsZSxcbiAgICBldmVudEtleSA9IHByb3BzLmV2ZW50S2V5LFxuICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KE1lbnVDb250ZXh0KSxcbiAgICBwcmVmaXhDbHMgPSBfUmVhY3QkdXNlQ29udGV4dC5wcmVmaXhDbHM7XG4gIHZhciBncm91cFByZWZpeENscyA9IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItaXRlbS1ncm91cFwiKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCJcbiAgfSwgcmVzdFByb3BzLCB7XG4gICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhncm91cFByZWZpeENscywgY2xhc3NOYW1lKVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChncm91cFByZWZpeENscywgXCItdGl0bGVcIiksXG4gICAgdGl0bGU6IHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycgPyB0aXRsZSA6IHVuZGVmaW5lZFxuICB9LCB0aXRsZSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwge1xuICAgIHJvbGU6IFwiZ3JvdXBcIixcbiAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KGdyb3VwUHJlZml4Q2xzLCBcIi1saXN0XCIpXG4gIH0sIGNoaWxkcmVuKSk7XG59KTtcbnZhciBNZW51SXRlbUdyb3VwID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIGV2ZW50S2V5ID0gcHJvcHMuZXZlbnRLZXksXG4gICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGNvbm5lY3RlZEtleVBhdGggPSB1c2VGdWxsUGF0aChldmVudEtleSk7XG4gIHZhciBjaGlsZExpc3QgPSBwYXJzZUNoaWxkcmVuKGNoaWxkcmVuLCBjb25uZWN0ZWRLZXlQYXRoKTtcbiAgdmFyIG1lYXN1cmUgPSB1c2VNZWFzdXJlKCk7XG4gIGlmIChtZWFzdXJlKSB7XG4gICAgcmV0dXJuIGNoaWxkTGlzdDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW50ZXJuYWxNZW51SXRlbUdyb3VwLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWZcbiAgfSwgb21pdChwcm9wcywgWyd3YXJuS2V5J10pKSwgY2hpbGRMaXN0KTtcbn0pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgTWVudUl0ZW1Hcm91cC5kaXNwbGF5TmFtZSA9ICdNZW51SXRlbUdyb3VwJztcbn1cbmV4cG9ydCBkZWZhdWx0IE1lbnVJdGVtR3JvdXA7IiwiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDJcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2ZcIjtcbnZhciBfZXhjbHVkZWQgPSBbXCJsYWJlbFwiLCBcImNoaWxkcmVuXCIsIFwia2V5XCIsIFwidHlwZVwiLCBcImV4dHJhXCJdO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IERpdmlkZXIgZnJvbSBcIi4uL0RpdmlkZXJcIjtcbmltcG9ydCBNZW51SXRlbSBmcm9tIFwiLi4vTWVudUl0ZW1cIjtcbmltcG9ydCBNZW51SXRlbUdyb3VwIGZyb20gXCIuLi9NZW51SXRlbUdyb3VwXCI7XG5pbXBvcnQgU3ViTWVudSBmcm9tIFwiLi4vU3ViTWVudVwiO1xuaW1wb3J0IHsgcGFyc2VDaGlsZHJlbiB9IGZyb20gXCIuL2NvbW1vblV0aWxcIjtcbmZ1bmN0aW9uIGNvbnZlcnRJdGVtc1RvTm9kZXMobGlzdCwgY29tcG9uZW50cywgcHJlZml4Q2xzKSB7XG4gIHZhciBNZXJnZWRNZW51SXRlbSA9IGNvbXBvbmVudHMuaXRlbSxcbiAgICBNZXJnZWRNZW51SXRlbUdyb3VwID0gY29tcG9uZW50cy5ncm91cCxcbiAgICBNZXJnZWRTdWJNZW51ID0gY29tcG9uZW50cy5zdWJtZW51LFxuICAgIE1lcmdlZERpdmlkZXIgPSBjb21wb25lbnRzLmRpdmlkZXI7XG4gIHJldHVybiAobGlzdCB8fCBbXSkubWFwKGZ1bmN0aW9uIChvcHQsIGluZGV4KSB7XG4gICAgaWYgKG9wdCAmJiBfdHlwZW9mKG9wdCkgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgX3JlZiA9IG9wdCxcbiAgICAgICAgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICBleHRyYSA9IF9yZWYuZXh0cmEsXG4gICAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICAgICAgdmFyIG1lcmdlZEtleSA9IGtleSAhPT0gbnVsbCAmJiBrZXkgIT09IHZvaWQgMCA/IGtleSA6IFwidG1wLVwiLmNvbmNhdChpbmRleCk7XG5cbiAgICAgIC8vIE1lbnVJdGVtR3JvdXAgJiBTdWJNZW51SXRlbVxuICAgICAgaWYgKGNoaWxkcmVuIHx8IHR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAvLyBHcm91cFxuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZXJnZWRNZW51SXRlbUdyb3VwLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBrZXk6IG1lcmdlZEtleVxuICAgICAgICAgIH0sIHJlc3RQcm9wcywge1xuICAgICAgICAgICAgdGl0bGU6IGxhYmVsXG4gICAgICAgICAgfSksIGNvbnZlcnRJdGVtc1RvTm9kZXMoY2hpbGRyZW4sIGNvbXBvbmVudHMsIHByZWZpeENscykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3ViIE1lbnVcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lcmdlZFN1Yk1lbnUsIF9leHRlbmRzKHtcbiAgICAgICAgICBrZXk6IG1lcmdlZEtleVxuICAgICAgICB9LCByZXN0UHJvcHMsIHtcbiAgICAgICAgICB0aXRsZTogbGFiZWxcbiAgICAgICAgfSksIGNvbnZlcnRJdGVtc1RvTm9kZXMoY2hpbGRyZW4sIGNvbXBvbmVudHMsIHByZWZpeENscykpO1xuICAgICAgfVxuXG4gICAgICAvLyBNZW51SXRlbSAmIERpdmlkZXJcbiAgICAgIGlmICh0eXBlID09PSAnZGl2aWRlcicpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lcmdlZERpdmlkZXIsIF9leHRlbmRzKHtcbiAgICAgICAgICBrZXk6IG1lcmdlZEtleVxuICAgICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZXJnZWRNZW51SXRlbSwgX2V4dGVuZHMoe1xuICAgICAgICBrZXk6IG1lcmdlZEtleVxuICAgICAgfSwgcmVzdFByb3BzLCB7XG4gICAgICAgIGV4dHJhOiBleHRyYVxuICAgICAgfSksIGxhYmVsLCAoISFleHRyYSB8fCBleHRyYSA9PT0gMCkgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLWl0ZW0tZXh0cmFcIilcbiAgICAgIH0sIGV4dHJhKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKG9wdCkge1xuICAgIHJldHVybiBvcHQ7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSXRlbXMoY2hpbGRyZW4sIGl0ZW1zLCBrZXlQYXRoLCBjb21wb25lbnRzLCBwcmVmaXhDbHMpIHtcbiAgdmFyIGNoaWxkTm9kZXMgPSBjaGlsZHJlbjtcbiAgdmFyIG1lcmdlZENvbXBvbmVudHMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBkaXZpZGVyOiBEaXZpZGVyLFxuICAgIGl0ZW06IE1lbnVJdGVtLFxuICAgIGdyb3VwOiBNZW51SXRlbUdyb3VwLFxuICAgIHN1Ym1lbnU6IFN1Yk1lbnVcbiAgfSwgY29tcG9uZW50cyk7XG4gIGlmIChpdGVtcykge1xuICAgIGNoaWxkTm9kZXMgPSBjb252ZXJ0SXRlbXNUb05vZGVzKGl0ZW1zLCBtZXJnZWRDb21wb25lbnRzLCBwcmVmaXhDbHMpO1xuICB9XG4gIHJldHVybiBwYXJzZUNoaWxkcmVuKGNoaWxkTm9kZXMsIGtleVBhdGgpO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyXCI7XG5pbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xudmFyIF9leGNsdWRlZCA9IFtcInByZWZpeENsc1wiLCBcInJvb3RDbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiLCBcInRhYkluZGV4XCIsIFwiaXRlbXNcIiwgXCJjaGlsZHJlblwiLCBcImRpcmVjdGlvblwiLCBcImlkXCIsIFwibW9kZVwiLCBcImlubGluZUNvbGxhcHNlZFwiLCBcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRPdmVyZmxvd1wiLCBcInN1Yk1lbnVPcGVuRGVsYXlcIiwgXCJzdWJNZW51Q2xvc2VEZWxheVwiLCBcImZvcmNlU3ViTWVudVJlbmRlclwiLCBcImRlZmF1bHRPcGVuS2V5c1wiLCBcIm9wZW5LZXlzXCIsIFwiYWN0aXZlS2V5XCIsIFwiZGVmYXVsdEFjdGl2ZUZpcnN0XCIsIFwic2VsZWN0YWJsZVwiLCBcIm11bHRpcGxlXCIsIFwiZGVmYXVsdFNlbGVjdGVkS2V5c1wiLCBcInNlbGVjdGVkS2V5c1wiLCBcIm9uU2VsZWN0XCIsIFwib25EZXNlbGVjdFwiLCBcImlubGluZUluZGVudFwiLCBcIm1vdGlvblwiLCBcImRlZmF1bHRNb3Rpb25zXCIsIFwidHJpZ2dlclN1Yk1lbnVBY3Rpb25cIiwgXCJidWlsdGluUGxhY2VtZW50c1wiLCBcIml0ZW1JY29uXCIsIFwiZXhwYW5kSWNvblwiLCBcIm92ZXJmbG93ZWRJbmRpY2F0b3JcIiwgXCJvdmVyZmxvd2VkSW5kaWNhdG9yUG9wdXBDbGFzc05hbWVcIiwgXCJnZXRQb3B1cENvbnRhaW5lclwiLCBcIm9uQ2xpY2tcIiwgXCJvbk9wZW5DaGFuZ2VcIiwgXCJvbktleURvd25cIiwgXCJvcGVuQW5pbWF0aW9uXCIsIFwib3BlblRyYW5zaXRpb25OYW1lXCIsIFwiX2ludGVybmFsUmVuZGVyTWVudUl0ZW1cIiwgXCJfaW50ZXJuYWxSZW5kZXJTdWJNZW51SXRlbVwiLCBcIl9pbnRlcm5hbENvbXBvbmVudHNcIl07XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBPdmVyZmxvdyBmcm9tICdyYy1vdmVyZmxvdyc7XG5pbXBvcnQgdXNlTWVyZ2VkU3RhdGUgZnJvbSBcInJjLXV0aWwvZXMvaG9va3MvdXNlTWVyZ2VkU3RhdGVcIjtcbmltcG9ydCBpc0VxdWFsIGZyb20gXCJyYy11dGlsL2VzL2lzRXF1YWxcIjtcbmltcG9ydCB3YXJuaW5nIGZyb20gXCJyYy11dGlsL2VzL3dhcm5pbmdcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgSWRDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dC9JZENvbnRleHRcIjtcbmltcG9ydCBNZW51Q29udGV4dFByb3ZpZGVyIGZyb20gXCIuL2NvbnRleHQvTWVudUNvbnRleHRcIjtcbmltcG9ydCB7IFBhdGhSZWdpc3RlckNvbnRleHQsIFBhdGhVc2VyQ29udGV4dCB9IGZyb20gXCIuL2NvbnRleHQvUGF0aENvbnRleHRcIjtcbmltcG9ydCBQcml2YXRlQ29udGV4dCBmcm9tIFwiLi9jb250ZXh0L1ByaXZhdGVDb250ZXh0XCI7XG5pbXBvcnQgeyBnZXRGb2N1c2FibGVFbGVtZW50cywgcmVmcmVzaEVsZW1lbnRzLCB1c2VBY2Nlc3NpYmlsaXR5IH0gZnJvbSBcIi4vaG9va3MvdXNlQWNjZXNzaWJpbGl0eVwiO1xuaW1wb3J0IHVzZUtleVJlY29yZHMsIHsgT1ZFUkZMT1dfS0VZIH0gZnJvbSBcIi4vaG9va3MvdXNlS2V5UmVjb3Jkc1wiO1xuaW1wb3J0IHVzZU1lbW9DYWxsYmFjayBmcm9tIFwiLi9ob29rcy91c2VNZW1vQ2FsbGJhY2tcIjtcbmltcG9ydCB1c2VVVUlEIGZyb20gXCIuL2hvb2tzL3VzZVVVSURcIjtcbmltcG9ydCBNZW51SXRlbSBmcm9tIFwiLi9NZW51SXRlbVwiO1xuaW1wb3J0IFN1Yk1lbnUgZnJvbSBcIi4vU3ViTWVudVwiO1xuaW1wb3J0IHsgcGFyc2VJdGVtcyB9IGZyb20gXCIuL3V0aWxzL25vZGVVdGlsXCI7XG5pbXBvcnQgeyB3YXJuSXRlbVByb3AgfSBmcm9tIFwiLi91dGlscy93YXJuVXRpbFwiO1xuXG4vKipcbiAqIE1lbnUgbW9kaWZ5IGFmdGVyIHJlZmFjdG9yOlxuICogIyMgQWRkXG4gKiAtIGRpc2FibGVkXG4gKlxuICogIyMgUmVtb3ZlXG4gKiAtIG9wZW5UcmFuc2l0aW9uTmFtZVxuICogLSBvcGVuQW5pbWF0aW9uXG4gKiAtIG9uRGVzdHJveVxuICogLSBzaWRlckNvbGxhcHNlZDogU2VlbXMgYW50ZCBkbyBub3QgdXNlIHRoaXMgcHJvcCAoTmVlZCB0ZXN0IGluIGFudGQpXG4gKiAtIGNvbGxhcHNlZFdpZHRoOiBTZWVtcyB0aGlzIGxvZ2ljIHNob3VsZCBiZSBoYW5kbGUgYnkgYW50ZCBMYXlvdXQuU2lkZXJcbiAqL1xuXG4vLyBvcHRpbWl6ZSBmb3IgcmVuZGVyXG52YXIgRU1QVFlfTElTVCA9IFtdO1xudmFyIE1lbnUgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICB2YXIgX2NoaWxkTGlzdCQ7XG4gIHZhciBfcmVmID0gcHJvcHMsXG4gICAgX3JlZiRwcmVmaXhDbHMgPSBfcmVmLnByZWZpeENscyxcbiAgICBwcmVmaXhDbHMgPSBfcmVmJHByZWZpeENscyA9PT0gdm9pZCAwID8gJ3JjLW1lbnUnIDogX3JlZiRwcmVmaXhDbHMsXG4gICAgcm9vdENsYXNzTmFtZSA9IF9yZWYucm9vdENsYXNzTmFtZSxcbiAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgX3JlZiR0YWJJbmRleCA9IF9yZWYudGFiSW5kZXgsXG4gICAgdGFiSW5kZXggPSBfcmVmJHRhYkluZGV4ID09PSB2b2lkIDAgPyAwIDogX3JlZiR0YWJJbmRleCxcbiAgICBpdGVtcyA9IF9yZWYuaXRlbXMsXG4gICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgIGRpcmVjdGlvbiA9IF9yZWYuZGlyZWN0aW9uLFxuICAgIGlkID0gX3JlZi5pZCxcbiAgICBfcmVmJG1vZGUgPSBfcmVmLm1vZGUsXG4gICAgbW9kZSA9IF9yZWYkbW9kZSA9PT0gdm9pZCAwID8gJ3ZlcnRpY2FsJyA6IF9yZWYkbW9kZSxcbiAgICBpbmxpbmVDb2xsYXBzZWQgPSBfcmVmLmlubGluZUNvbGxhcHNlZCxcbiAgICBkaXNhYmxlZCA9IF9yZWYuZGlzYWJsZWQsXG4gICAgZGlzYWJsZWRPdmVyZmxvdyA9IF9yZWYuZGlzYWJsZWRPdmVyZmxvdyxcbiAgICBfcmVmJHN1Yk1lbnVPcGVuRGVsYXkgPSBfcmVmLnN1Yk1lbnVPcGVuRGVsYXksXG4gICAgc3ViTWVudU9wZW5EZWxheSA9IF9yZWYkc3ViTWVudU9wZW5EZWxheSA9PT0gdm9pZCAwID8gMC4xIDogX3JlZiRzdWJNZW51T3BlbkRlbGF5LFxuICAgIF9yZWYkc3ViTWVudUNsb3NlRGVsYSA9IF9yZWYuc3ViTWVudUNsb3NlRGVsYXksXG4gICAgc3ViTWVudUNsb3NlRGVsYXkgPSBfcmVmJHN1Yk1lbnVDbG9zZURlbGEgPT09IHZvaWQgMCA/IDAuMSA6IF9yZWYkc3ViTWVudUNsb3NlRGVsYSxcbiAgICBmb3JjZVN1Yk1lbnVSZW5kZXIgPSBfcmVmLmZvcmNlU3ViTWVudVJlbmRlcixcbiAgICBkZWZhdWx0T3BlbktleXMgPSBfcmVmLmRlZmF1bHRPcGVuS2V5cyxcbiAgICBvcGVuS2V5cyA9IF9yZWYub3BlbktleXMsXG4gICAgYWN0aXZlS2V5ID0gX3JlZi5hY3RpdmVLZXksXG4gICAgZGVmYXVsdEFjdGl2ZUZpcnN0ID0gX3JlZi5kZWZhdWx0QWN0aXZlRmlyc3QsXG4gICAgX3JlZiRzZWxlY3RhYmxlID0gX3JlZi5zZWxlY3RhYmxlLFxuICAgIHNlbGVjdGFibGUgPSBfcmVmJHNlbGVjdGFibGUgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHNlbGVjdGFibGUsXG4gICAgX3JlZiRtdWx0aXBsZSA9IF9yZWYubXVsdGlwbGUsXG4gICAgbXVsdGlwbGUgPSBfcmVmJG11bHRpcGxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkbXVsdGlwbGUsXG4gICAgZGVmYXVsdFNlbGVjdGVkS2V5cyA9IF9yZWYuZGVmYXVsdFNlbGVjdGVkS2V5cyxcbiAgICBzZWxlY3RlZEtleXMgPSBfcmVmLnNlbGVjdGVkS2V5cyxcbiAgICBvblNlbGVjdCA9IF9yZWYub25TZWxlY3QsXG4gICAgb25EZXNlbGVjdCA9IF9yZWYub25EZXNlbGVjdCxcbiAgICBfcmVmJGlubGluZUluZGVudCA9IF9yZWYuaW5saW5lSW5kZW50LFxuICAgIGlubGluZUluZGVudCA9IF9yZWYkaW5saW5lSW5kZW50ID09PSB2b2lkIDAgPyAyNCA6IF9yZWYkaW5saW5lSW5kZW50LFxuICAgIG1vdGlvbiA9IF9yZWYubW90aW9uLFxuICAgIGRlZmF1bHRNb3Rpb25zID0gX3JlZi5kZWZhdWx0TW90aW9ucyxcbiAgICBfcmVmJHRyaWdnZXJTdWJNZW51QWMgPSBfcmVmLnRyaWdnZXJTdWJNZW51QWN0aW9uLFxuICAgIHRyaWdnZXJTdWJNZW51QWN0aW9uID0gX3JlZiR0cmlnZ2VyU3ViTWVudUFjID09PSB2b2lkIDAgPyAnaG92ZXInIDogX3JlZiR0cmlnZ2VyU3ViTWVudUFjLFxuICAgIGJ1aWx0aW5QbGFjZW1lbnRzID0gX3JlZi5idWlsdGluUGxhY2VtZW50cyxcbiAgICBpdGVtSWNvbiA9IF9yZWYuaXRlbUljb24sXG4gICAgZXhwYW5kSWNvbiA9IF9yZWYuZXhwYW5kSWNvbixcbiAgICBfcmVmJG92ZXJmbG93ZWRJbmRpY2EgPSBfcmVmLm92ZXJmbG93ZWRJbmRpY2F0b3IsXG4gICAgb3ZlcmZsb3dlZEluZGljYXRvciA9IF9yZWYkb3ZlcmZsb3dlZEluZGljYSA9PT0gdm9pZCAwID8gJy4uLicgOiBfcmVmJG92ZXJmbG93ZWRJbmRpY2EsXG4gICAgb3ZlcmZsb3dlZEluZGljYXRvclBvcHVwQ2xhc3NOYW1lID0gX3JlZi5vdmVyZmxvd2VkSW5kaWNhdG9yUG9wdXBDbGFzc05hbWUsXG4gICAgZ2V0UG9wdXBDb250YWluZXIgPSBfcmVmLmdldFBvcHVwQ29udGFpbmVyLFxuICAgIG9uQ2xpY2sgPSBfcmVmLm9uQ2xpY2ssXG4gICAgb25PcGVuQ2hhbmdlID0gX3JlZi5vbk9wZW5DaGFuZ2UsXG4gICAgb25LZXlEb3duID0gX3JlZi5vbktleURvd24sXG4gICAgb3BlbkFuaW1hdGlvbiA9IF9yZWYub3BlbkFuaW1hdGlvbixcbiAgICBvcGVuVHJhbnNpdGlvbk5hbWUgPSBfcmVmLm9wZW5UcmFuc2l0aW9uTmFtZSxcbiAgICBfaW50ZXJuYWxSZW5kZXJNZW51SXRlbSA9IF9yZWYuX2ludGVybmFsUmVuZGVyTWVudUl0ZW0sXG4gICAgX2ludGVybmFsUmVuZGVyU3ViTWVudUl0ZW0gPSBfcmVmLl9pbnRlcm5hbFJlbmRlclN1Yk1lbnVJdGVtLFxuICAgIF9pbnRlcm5hbENvbXBvbmVudHMgPSBfcmVmLl9pbnRlcm5hbENvbXBvbmVudHMsXG4gICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtwYXJzZUl0ZW1zKGNoaWxkcmVuLCBpdGVtcywgRU1QVFlfTElTVCwgX2ludGVybmFsQ29tcG9uZW50cywgcHJlZml4Q2xzKSwgcGFyc2VJdGVtcyhjaGlsZHJlbiwgaXRlbXMsIEVNUFRZX0xJU1QsIHt9LCBwcmVmaXhDbHMpXTtcbiAgICB9LCBbY2hpbGRyZW4sIGl0ZW1zLCBfaW50ZXJuYWxDb21wb25lbnRzXSksXG4gICAgX1JlYWN0JHVzZU1lbW8yID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZU1lbW8sIDIpLFxuICAgIGNoaWxkTGlzdCA9IF9SZWFjdCR1c2VNZW1vMlswXSxcbiAgICBtZWFzdXJlQ2hpbGRMaXN0ID0gX1JlYWN0JHVzZU1lbW8yWzFdO1xuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgIG1vdW50ZWQgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgIHNldE1vdW50ZWQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuICB2YXIgY29udGFpbmVyUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIHZhciB1dWlkID0gdXNlVVVJRChpZCk7XG4gIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gJ3J0bCc7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBXYXJuID09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuaW5nKCFvcGVuQW5pbWF0aW9uICYmICFvcGVuVHJhbnNpdGlvbk5hbWUsICdgb3BlbkFuaW1hdGlvbmAgYW5kIGBvcGVuVHJhbnNpdGlvbk5hbWVgIGlzIHJlbW92ZWQuIFBsZWFzZSB1c2UgYG1vdGlvbmAgb3IgYGRlZmF1bHRNb3Rpb25gIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09IE9wZW4gPT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgX3VzZU1lcmdlZFN0YXRlID0gdXNlTWVyZ2VkU3RhdGUoZGVmYXVsdE9wZW5LZXlzLCB7XG4gICAgICB2YWx1ZTogb3BlbktleXMsXG4gICAgICBwb3N0U3RhdGU6IGZ1bmN0aW9uIHBvc3RTdGF0ZShrZXlzKSB7XG4gICAgICAgIHJldHVybiBrZXlzIHx8IEVNUFRZX0xJU1Q7XG4gICAgICB9XG4gICAgfSksXG4gICAgX3VzZU1lcmdlZFN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VNZXJnZWRTdGF0ZSwgMiksXG4gICAgbWVyZ2VkT3BlbktleXMgPSBfdXNlTWVyZ2VkU3RhdGUyWzBdLFxuICAgIHNldE1lcmdlZE9wZW5LZXlzID0gX3VzZU1lcmdlZFN0YXRlMlsxXTtcblxuICAvLyBSZWFjdCAxOCB3aWxsIG1lcmdlIG1vdXNlIGV2ZW50IHdoaWNoIG1lYW5zIHdlIG9wZW4ga2V5IHdpbGwgbm90IHN5bmNcbiAgLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vYW50LWRlc2lnbi9hbnQtZGVzaWduL2lzc3Vlcy8zODgxOFxuICB2YXIgdHJpZ2dlck9wZW5LZXlzID0gZnVuY3Rpb24gdHJpZ2dlck9wZW5LZXlzKGtleXMpIHtcbiAgICB2YXIgZm9yY2VGbHVzaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgZnVuY3Rpb24gZG9VcGRhdGUoKSB7XG4gICAgICBzZXRNZXJnZWRPcGVuS2V5cyhrZXlzKTtcbiAgICAgIG9uT3BlbkNoYW5nZSA9PT0gbnVsbCB8fCBvbk9wZW5DaGFuZ2UgPT09IHZvaWQgMCB8fCBvbk9wZW5DaGFuZ2Uoa2V5cyk7XG4gICAgfVxuICAgIGlmIChmb3JjZUZsdXNoKSB7XG4gICAgICBmbHVzaFN5bmMoZG9VcGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb1VwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyA+Pj4+PiBDYWNoZSAmIFJlc2V0IG9wZW4ga2V5cyB3aGVuIGlubGluZUNvbGxhcHNlZCBjaGFuZ2VkXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUobWVyZ2VkT3BlbktleXMpLFxuICAgIF9SZWFjdCR1c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUzLCAyKSxcbiAgICBpbmxpbmVDYWNoZU9wZW5LZXlzID0gX1JlYWN0JHVzZVN0YXRlNFswXSxcbiAgICBzZXRJbmxpbmVDYWNoZU9wZW5LZXlzID0gX1JlYWN0JHVzZVN0YXRlNFsxXTtcbiAgdmFyIG1vdW50UmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09IE1vZGUgPT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgX1JlYWN0JHVzZU1lbW8zID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoKG1vZGUgPT09ICdpbmxpbmUnIHx8IG1vZGUgPT09ICd2ZXJ0aWNhbCcpICYmIGlubGluZUNvbGxhcHNlZCkge1xuICAgICAgICByZXR1cm4gWyd2ZXJ0aWNhbCcsIGlubGluZUNvbGxhcHNlZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gW21vZGUsIGZhbHNlXTtcbiAgICB9LCBbbW9kZSwgaW5saW5lQ29sbGFwc2VkXSksXG4gICAgX1JlYWN0JHVzZU1lbW80ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZU1lbW8zLCAyKSxcbiAgICBtZXJnZWRNb2RlID0gX1JlYWN0JHVzZU1lbW80WzBdLFxuICAgIG1lcmdlZElubGluZUNvbGxhcHNlZCA9IF9SZWFjdCR1c2VNZW1vNFsxXTtcbiAgdmFyIGlzSW5saW5lTW9kZSA9IG1lcmdlZE1vZGUgPT09ICdpbmxpbmUnO1xuICB2YXIgX1JlYWN0JHVzZVN0YXRlNSA9IFJlYWN0LnVzZVN0YXRlKG1lcmdlZE1vZGUpLFxuICAgIF9SZWFjdCR1c2VTdGF0ZTYgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGU1LCAyKSxcbiAgICBpbnRlcm5hbE1vZGUgPSBfUmVhY3QkdXNlU3RhdGU2WzBdLFxuICAgIHNldEludGVybmFsTW9kZSA9IF9SZWFjdCR1c2VTdGF0ZTZbMV07XG4gIHZhciBfUmVhY3QkdXNlU3RhdGU3ID0gUmVhY3QudXNlU3RhdGUobWVyZ2VkSW5saW5lQ29sbGFwc2VkKSxcbiAgICBfUmVhY3QkdXNlU3RhdGU4ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlNywgMiksXG4gICAgaW50ZXJuYWxJbmxpbmVDb2xsYXBzZWQgPSBfUmVhY3QkdXNlU3RhdGU4WzBdLFxuICAgIHNldEludGVybmFsSW5saW5lQ29sbGFwc2VkID0gX1JlYWN0JHVzZVN0YXRlOFsxXTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbnRlcm5hbE1vZGUobWVyZ2VkTW9kZSk7XG4gICAgc2V0SW50ZXJuYWxJbmxpbmVDb2xsYXBzZWQobWVyZ2VkSW5saW5lQ29sbGFwc2VkKTtcbiAgICBpZiAoIW1vdW50UmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU3luY2hyb25vdXNseSB1cGRhdGUgTWVyZ2VkT3BlbktleXNcbiAgICBpZiAoaXNJbmxpbmVNb2RlKSB7XG4gICAgICBzZXRNZXJnZWRPcGVuS2V5cyhpbmxpbmVDYWNoZU9wZW5LZXlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJpZ2dlciBvcGVuIGV2ZW50IGluIGNhc2UgaXRzIGluIGNvbnRyb2xcbiAgICAgIHRyaWdnZXJPcGVuS2V5cyhFTVBUWV9MSVNUKTtcbiAgICB9XG4gIH0sIFttZXJnZWRNb2RlLCBtZXJnZWRJbmxpbmVDb2xsYXBzZWRdKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09IFJlc3BvbnNpdmUgPT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgX1JlYWN0JHVzZVN0YXRlOSA9IFJlYWN0LnVzZVN0YXRlKDApLFxuICAgIF9SZWFjdCR1c2VTdGF0ZTEwID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlOSwgMiksXG4gICAgbGFzdFZpc2libGVJbmRleCA9IF9SZWFjdCR1c2VTdGF0ZTEwWzBdLFxuICAgIHNldExhc3RWaXNpYmxlSW5kZXggPSBfUmVhY3QkdXNlU3RhdGUxMFsxXTtcbiAgdmFyIGFsbFZpc2libGUgPSBsYXN0VmlzaWJsZUluZGV4ID49IGNoaWxkTGlzdC5sZW5ndGggLSAxIHx8IGludGVybmFsTW9kZSAhPT0gJ2hvcml6b250YWwnIHx8IGRpc2FibGVkT3ZlcmZsb3c7XG5cbiAgLy8gQ2FjaGVcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNJbmxpbmVNb2RlKSB7XG4gICAgICBzZXRJbmxpbmVDYWNoZU9wZW5LZXlzKG1lcmdlZE9wZW5LZXlzKTtcbiAgICB9XG4gIH0sIFttZXJnZWRPcGVuS2V5c10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIG1vdW50UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBtb3VudFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT0gUGF0aCA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBfdXNlS2V5UmVjb3JkcyA9IHVzZUtleVJlY29yZHMoKSxcbiAgICByZWdpc3RlclBhdGggPSBfdXNlS2V5UmVjb3Jkcy5yZWdpc3RlclBhdGgsXG4gICAgdW5yZWdpc3RlclBhdGggPSBfdXNlS2V5UmVjb3Jkcy51bnJlZ2lzdGVyUGF0aCxcbiAgICByZWZyZXNoT3ZlcmZsb3dLZXlzID0gX3VzZUtleVJlY29yZHMucmVmcmVzaE92ZXJmbG93S2V5cyxcbiAgICBpc1N1YlBhdGhLZXkgPSBfdXNlS2V5UmVjb3Jkcy5pc1N1YlBhdGhLZXksXG4gICAgZ2V0S2V5UGF0aCA9IF91c2VLZXlSZWNvcmRzLmdldEtleVBhdGgsXG4gICAgZ2V0S2V5cyA9IF91c2VLZXlSZWNvcmRzLmdldEtleXMsXG4gICAgZ2V0U3ViUGF0aEtleXMgPSBfdXNlS2V5UmVjb3Jkcy5nZXRTdWJQYXRoS2V5cztcbiAgdmFyIHJlZ2lzdGVyUGF0aENvbnRleHQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJQYXRoOiByZWdpc3RlclBhdGgsXG4gICAgICB1bnJlZ2lzdGVyUGF0aDogdW5yZWdpc3RlclBhdGhcbiAgICB9O1xuICB9LCBbcmVnaXN0ZXJQYXRoLCB1bnJlZ2lzdGVyUGF0aF0pO1xuICB2YXIgcGF0aFVzZXJDb250ZXh0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzU3ViUGF0aEtleTogaXNTdWJQYXRoS2V5XG4gICAgfTtcbiAgfSwgW2lzU3ViUGF0aEtleV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZnJlc2hPdmVyZmxvd0tleXMoYWxsVmlzaWJsZSA/IEVNUFRZX0xJU1QgOiBjaGlsZExpc3Quc2xpY2UobGFzdFZpc2libGVJbmRleCArIDEpLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5rZXk7XG4gICAgfSkpO1xuICB9LCBbbGFzdFZpc2libGVJbmRleCwgYWxsVmlzaWJsZV0pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PSBBY3RpdmUgPT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBfdXNlTWVyZ2VkU3RhdGUzID0gdXNlTWVyZ2VkU3RhdGUoYWN0aXZlS2V5IHx8IGRlZmF1bHRBY3RpdmVGaXJzdCAmJiAoKF9jaGlsZExpc3QkID0gY2hpbGRMaXN0WzBdKSA9PT0gbnVsbCB8fCBfY2hpbGRMaXN0JCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NoaWxkTGlzdCQua2V5KSwge1xuICAgICAgdmFsdWU6IGFjdGl2ZUtleVxuICAgIH0pLFxuICAgIF91c2VNZXJnZWRTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlTWVyZ2VkU3RhdGUzLCAyKSxcbiAgICBtZXJnZWRBY3RpdmVLZXkgPSBfdXNlTWVyZ2VkU3RhdGU0WzBdLFxuICAgIHNldE1lcmdlZEFjdGl2ZUtleSA9IF91c2VNZXJnZWRTdGF0ZTRbMV07XG4gIHZhciBvbkFjdGl2ZSA9IHVzZU1lbW9DYWxsYmFjayhmdW5jdGlvbiAoa2V5KSB7XG4gICAgc2V0TWVyZ2VkQWN0aXZlS2V5KGtleSk7XG4gIH0pO1xuICB2YXIgb25JbmFjdGl2ZSA9IHVzZU1lbW9DYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgc2V0TWVyZ2VkQWN0aXZlS2V5KHVuZGVmaW5lZCk7XG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXN0OiBjb250YWluZXJSZWYuY3VycmVudCxcbiAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfY2hpbGRMaXN0JGZpbmQ7XG4gICAgICAgIHZhciBrZXlzID0gZ2V0S2V5cygpO1xuICAgICAgICB2YXIgX3JlZnJlc2hFbGVtZW50cyA9IHJlZnJlc2hFbGVtZW50cyhrZXlzLCB1dWlkKSxcbiAgICAgICAgICBlbGVtZW50cyA9IF9yZWZyZXNoRWxlbWVudHMuZWxlbWVudHMsXG4gICAgICAgICAga2V5MmVsZW1lbnQgPSBfcmVmcmVzaEVsZW1lbnRzLmtleTJlbGVtZW50LFxuICAgICAgICAgIGVsZW1lbnQya2V5ID0gX3JlZnJlc2hFbGVtZW50cy5lbGVtZW50MmtleTtcbiAgICAgICAgdmFyIGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoY29udGFpbmVyUmVmLmN1cnJlbnQsIGVsZW1lbnRzKTtcbiAgICAgICAgdmFyIHNob3VsZEZvY3VzS2V5ID0gbWVyZ2VkQWN0aXZlS2V5ICE9PSBudWxsICYmIG1lcmdlZEFjdGl2ZUtleSAhPT0gdm9pZCAwID8gbWVyZ2VkQWN0aXZlS2V5IDogZm9jdXNhYmxlRWxlbWVudHNbMF0gPyBlbGVtZW50MmtleS5nZXQoZm9jdXNhYmxlRWxlbWVudHNbMF0pIDogKF9jaGlsZExpc3QkZmluZCA9IGNoaWxkTGlzdC5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuICFub2RlLnByb3BzLmRpc2FibGVkO1xuICAgICAgICB9KSkgPT09IG51bGwgfHwgX2NoaWxkTGlzdCRmaW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2hpbGRMaXN0JGZpbmQua2V5O1xuICAgICAgICB2YXIgZWxlbWVudFRvRm9jdXMgPSBrZXkyZWxlbWVudC5nZXQoc2hvdWxkRm9jdXNLZXkpO1xuICAgICAgICBpZiAoc2hvdWxkRm9jdXNLZXkgJiYgZWxlbWVudFRvRm9jdXMpIHtcbiAgICAgICAgICB2YXIgX2VsZW1lbnRUb0ZvY3VzJGZvY3VzO1xuICAgICAgICAgIGVsZW1lbnRUb0ZvY3VzID09PSBudWxsIHx8IGVsZW1lbnRUb0ZvY3VzID09PSB2b2lkIDAgfHwgKF9lbGVtZW50VG9Gb2N1cyRmb2N1cyA9IGVsZW1lbnRUb0ZvY3VzLmZvY3VzKSA9PT0gbnVsbCB8fCBfZWxlbWVudFRvRm9jdXMkZm9jdXMgPT09IHZvaWQgMCB8fCBfZWxlbWVudFRvRm9jdXMkZm9jdXMuY2FsbChlbGVtZW50VG9Gb2N1cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gU2VsZWN0ID09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA+Pj4+PiBTZWxlY3Qga2V5c1xuICB2YXIgX3VzZU1lcmdlZFN0YXRlNSA9IHVzZU1lcmdlZFN0YXRlKGRlZmF1bHRTZWxlY3RlZEtleXMgfHwgW10sIHtcbiAgICAgIHZhbHVlOiBzZWxlY3RlZEtleXMsXG4gICAgICAvLyBMZWdhY3kgY29udmVydCBrZXkgdG8gYXJyYXlcbiAgICAgIHBvc3RTdGF0ZTogZnVuY3Rpb24gcG9zdFN0YXRlKGtleXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5cyA9PT0gbnVsbCB8fCBrZXlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gRU1QVFlfTElTVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2tleXNdO1xuICAgICAgfVxuICAgIH0pLFxuICAgIF91c2VNZXJnZWRTdGF0ZTYgPSBfc2xpY2VkVG9BcnJheShfdXNlTWVyZ2VkU3RhdGU1LCAyKSxcbiAgICBtZXJnZWRTZWxlY3RLZXlzID0gX3VzZU1lcmdlZFN0YXRlNlswXSxcbiAgICBzZXRNZXJnZWRTZWxlY3RLZXlzID0gX3VzZU1lcmdlZFN0YXRlNlsxXTtcblxuICAvLyA+Pj4+PiBUcmlnZ2VyIHNlbGVjdFxuICB2YXIgdHJpZ2dlclNlbGVjdGlvbiA9IGZ1bmN0aW9uIHRyaWdnZXJTZWxlY3Rpb24oaW5mbykge1xuICAgIGlmIChzZWxlY3RhYmxlKSB7XG4gICAgICAvLyBJbnNlcnQgb3IgUmVtb3ZlXG4gICAgICB2YXIgdGFyZ2V0S2V5ID0gaW5mby5rZXk7XG4gICAgICB2YXIgZXhpc3QgPSBtZXJnZWRTZWxlY3RLZXlzLmluY2x1ZGVzKHRhcmdldEtleSk7XG4gICAgICB2YXIgbmV3U2VsZWN0S2V5cztcbiAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICBpZiAoZXhpc3QpIHtcbiAgICAgICAgICBuZXdTZWxlY3RLZXlzID0gbWVyZ2VkU2VsZWN0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleSAhPT0gdGFyZ2V0S2V5O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1NlbGVjdEtleXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG1lcmdlZFNlbGVjdEtleXMpLCBbdGFyZ2V0S2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1NlbGVjdEtleXMgPSBbdGFyZ2V0S2V5XTtcbiAgICAgIH1cbiAgICAgIHNldE1lcmdlZFNlbGVjdEtleXMobmV3U2VsZWN0S2V5cyk7XG5cbiAgICAgIC8vIFRyaWdnZXIgZXZlbnRcbiAgICAgIHZhciBzZWxlY3RJbmZvID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpbmZvKSwge30sIHtcbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBuZXdTZWxlY3RLZXlzXG4gICAgICB9KTtcbiAgICAgIGlmIChleGlzdCkge1xuICAgICAgICBvbkRlc2VsZWN0ID09PSBudWxsIHx8IG9uRGVzZWxlY3QgPT09IHZvaWQgMCB8fCBvbkRlc2VsZWN0KHNlbGVjdEluZm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25TZWxlY3QgPT09IG51bGwgfHwgb25TZWxlY3QgPT09IHZvaWQgMCB8fCBvblNlbGVjdChzZWxlY3RJbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGF0ZXZlciBzZWxlY3RhYmxlLCBhbHdheXMgY2xvc2UgaXRcbiAgICBpZiAoIW11bHRpcGxlICYmIG1lcmdlZE9wZW5LZXlzLmxlbmd0aCAmJiBpbnRlcm5hbE1vZGUgIT09ICdpbmxpbmUnKSB7XG4gICAgICB0cmlnZ2VyT3BlbktleXMoRU1QVFlfTElTVCk7XG4gICAgfVxuICB9O1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT0gT3BlbiA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8qKlxuICAgKiBDbGljayBmb3IgaXRlbS4gU3ViTWVudSBkbyBub3QgaGF2ZSBzZWxlY3Rpb24gc3RhdHVzXG4gICAqL1xuICB2YXIgb25JbnRlcm5hbENsaWNrID0gdXNlTWVtb0NhbGxiYWNrKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgb25DbGljayA9PT0gbnVsbCB8fCBvbkNsaWNrID09PSB2b2lkIDAgfHwgb25DbGljayh3YXJuSXRlbVByb3AoaW5mbykpO1xuICAgIHRyaWdnZXJTZWxlY3Rpb24oaW5mbyk7XG4gIH0pO1xuICB2YXIgb25JbnRlcm5hbE9wZW5DaGFuZ2UgPSB1c2VNZW1vQ2FsbGJhY2soZnVuY3Rpb24gKGtleSwgb3Blbikge1xuICAgIHZhciBuZXdPcGVuS2V5cyA9IG1lcmdlZE9wZW5LZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIGsgIT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAob3Blbikge1xuICAgICAgbmV3T3BlbktleXMucHVzaChrZXkpO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJuYWxNb2RlICE9PSAnaW5saW5lJykge1xuICAgICAgLy8gV2UgbmVlZCBmaW5kIGFsbCByZWxhdGVkIHBvcHVwIHRvIGNsb3NlXG4gICAgICB2YXIgc3ViUGF0aEtleXMgPSBnZXRTdWJQYXRoS2V5cyhrZXkpO1xuICAgICAgbmV3T3BlbktleXMgPSBuZXdPcGVuS2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuICFzdWJQYXRoS2V5cy5oYXMoayk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0VxdWFsKG1lcmdlZE9wZW5LZXlzLCBuZXdPcGVuS2V5cywgdHJ1ZSkpIHtcbiAgICAgIHRyaWdnZXJPcGVuS2V5cyhuZXdPcGVuS2V5cywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBBY2Nlc3NpYmlsaXR5ID09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgdHJpZ2dlckFjY2Vzc2liaWxpdHlPcGVuID0gZnVuY3Rpb24gdHJpZ2dlckFjY2Vzc2liaWxpdHlPcGVuKGtleSwgb3Blbikge1xuICAgIHZhciBuZXh0T3BlbiA9IG9wZW4gIT09IG51bGwgJiYgb3BlbiAhPT0gdm9pZCAwID8gb3BlbiA6ICFtZXJnZWRPcGVuS2V5cy5pbmNsdWRlcyhrZXkpO1xuICAgIG9uSW50ZXJuYWxPcGVuQ2hhbmdlKGtleSwgbmV4dE9wZW4pO1xuICB9O1xuICB2YXIgb25JbnRlcm5hbEtleURvd24gPSB1c2VBY2Nlc3NpYmlsaXR5KGludGVybmFsTW9kZSwgbWVyZ2VkQWN0aXZlS2V5LCBpc1J0bCwgdXVpZCwgY29udGFpbmVyUmVmLCBnZXRLZXlzLCBnZXRLZXlQYXRoLCBzZXRNZXJnZWRBY3RpdmVLZXksIHRyaWdnZXJBY2Nlc3NpYmlsaXR5T3Blbiwgb25LZXlEb3duKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gRWZmZWN0ID09PT09PT09PT09PT09PT09PT09PT09PVxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gIH0sIFtdKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PSBDb250ZXh0ID09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgcHJpdmF0ZUNvbnRleHQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2ludGVybmFsUmVuZGVyTWVudUl0ZW06IF9pbnRlcm5hbFJlbmRlck1lbnVJdGVtLFxuICAgICAgX2ludGVybmFsUmVuZGVyU3ViTWVudUl0ZW06IF9pbnRlcm5hbFJlbmRlclN1Yk1lbnVJdGVtXG4gICAgfTtcbiAgfSwgW19pbnRlcm5hbFJlbmRlck1lbnVJdGVtLCBfaW50ZXJuYWxSZW5kZXJTdWJNZW51SXRlbV0pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PSBSZW5kZXIgPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLy8gPj4+Pj4gQ2hpbGRyZW5cbiAgdmFyIHdyYXBwZWRDaGlsZExpc3QgPSBpbnRlcm5hbE1vZGUgIT09ICdob3Jpem9udGFsJyB8fCBkaXNhYmxlZE92ZXJmbG93ID8gY2hpbGRMaXN0IDpcbiAgLy8gTmVlZCB3cmFwIGZvciBvdmVyZmxvdyBkcm9wZG93biB0aGF0IGRvIG5vdCByZXNwb25zZSBmb3Igb3BlblxuICBjaGlsZExpc3QubWFwKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgLy8gQWx3YXlzIHdyYXAgcHJvdmlkZXIgdG8gYXZvaWQgc3ViIG5vZGUgcmUtbW91bnRcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVudUNvbnRleHRQcm92aWRlciwge1xuICAgICAgICBrZXk6IGNoaWxkLmtleSxcbiAgICAgICAgb3ZlcmZsb3dEaXNhYmxlZDogaW5kZXggPiBsYXN0VmlzaWJsZUluZGV4XG4gICAgICB9LCBjaGlsZClcbiAgICApO1xuICB9KTtcblxuICAvLyA+Pj4+PiBDb250YWluZXJcbiAgdmFyIGNvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJmbG93LCBfZXh0ZW5kcyh7XG4gICAgaWQ6IGlkLFxuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIHByZWZpeENsczogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1vdmVyZmxvd1wiKSxcbiAgICBjb21wb25lbnQ6IFwidWxcIixcbiAgICBpdGVtQ29tcG9uZW50OiBNZW51SXRlbSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMocHJlZml4Q2xzLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXJvb3RcIiksIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItXCIpLmNvbmNhdChpbnRlcm5hbE1vZGUpLCBjbGFzc05hbWUsIF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItaW5saW5lLWNvbGxhcHNlZFwiKSwgaW50ZXJuYWxJbmxpbmVDb2xsYXBzZWQpLCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXJ0bFwiKSwgaXNSdGwpLCByb290Q2xhc3NOYW1lKSxcbiAgICBkaXI6IGRpcmVjdGlvbixcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgcm9sZTogXCJtZW51XCIsXG4gICAgdGFiSW5kZXg6IHRhYkluZGV4LFxuICAgIGRhdGE6IHdyYXBwZWRDaGlsZExpc3QsXG4gICAgcmVuZGVyUmF3SXRlbTogZnVuY3Rpb24gcmVuZGVyUmF3SXRlbShub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIHJlbmRlclJhd1Jlc3Q6IGZ1bmN0aW9uIHJlbmRlclJhd1Jlc3Qob21pdEl0ZW1zKSB7XG4gICAgICAvLyBXZSB1c2Ugb3JpZ2luIGxpc3Qgc2luY2Ugd3JhcHBlZCBsaXN0IHVzZSBjb250ZXh0IHRvIHByZXZlbnQgb3BlblxuICAgICAgdmFyIGxlbiA9IG9taXRJdGVtcy5sZW5ndGg7XG4gICAgICB2YXIgb3JpZ2luT21pdEl0ZW1zID0gbGVuID8gY2hpbGRMaXN0LnNsaWNlKC1sZW4pIDogbnVsbDtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTdWJNZW51LCB7XG4gICAgICAgIGV2ZW50S2V5OiBPVkVSRkxPV19LRVksXG4gICAgICAgIHRpdGxlOiBvdmVyZmxvd2VkSW5kaWNhdG9yLFxuICAgICAgICBkaXNhYmxlZDogYWxsVmlzaWJsZSxcbiAgICAgICAgaW50ZXJuYWxQb3B1cENsb3NlOiBsZW4gPT09IDAsXG4gICAgICAgIHBvcHVwQ2xhc3NOYW1lOiBvdmVyZmxvd2VkSW5kaWNhdG9yUG9wdXBDbGFzc05hbWVcbiAgICAgIH0sIG9yaWdpbk9taXRJdGVtcyk7XG4gICAgfSxcbiAgICBtYXhDb3VudDogaW50ZXJuYWxNb2RlICE9PSAnaG9yaXpvbnRhbCcgfHwgZGlzYWJsZWRPdmVyZmxvdyA/IE92ZXJmbG93LklOVkFMSURBVEUgOiBPdmVyZmxvdy5SRVNQT05TSVZFLFxuICAgIHNzcjogXCJmdWxsXCIsXG4gICAgXCJkYXRhLW1lbnUtbGlzdFwiOiB0cnVlLFxuICAgIG9uVmlzaWJsZUNoYW5nZTogZnVuY3Rpb24gb25WaXNpYmxlQ2hhbmdlKG5ld0xhc3RJbmRleCkge1xuICAgICAgc2V0TGFzdFZpc2libGVJbmRleChuZXdMYXN0SW5kZXgpO1xuICAgIH0sXG4gICAgb25LZXlEb3duOiBvbkludGVybmFsS2V5RG93blxuICB9LCByZXN0UHJvcHMpKTtcblxuICAvLyA+Pj4+PiBSZW5kZXJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFByaXZhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHByaXZhdGVDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KElkQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB1dWlkXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbnVDb250ZXh0UHJvdmlkZXIsIHtcbiAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICByb290Q2xhc3NOYW1lOiByb290Q2xhc3NOYW1lLFxuICAgIG1vZGU6IGludGVybmFsTW9kZSxcbiAgICBvcGVuS2V5czogbWVyZ2VkT3BlbktleXMsXG4gICAgcnRsOiBpc1J0bFxuICAgIC8vIERpc2FibGVkXG4gICAgLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZFxuICAgIC8vIE1vdGlvblxuICAgICxcbiAgICBtb3Rpb246IG1vdW50ZWQgPyBtb3Rpb24gOiBudWxsLFxuICAgIGRlZmF1bHRNb3Rpb25zOiBtb3VudGVkID8gZGVmYXVsdE1vdGlvbnMgOiBudWxsXG4gICAgLy8gQWN0aXZlXG4gICAgLFxuICAgIGFjdGl2ZUtleTogbWVyZ2VkQWN0aXZlS2V5LFxuICAgIG9uQWN0aXZlOiBvbkFjdGl2ZSxcbiAgICBvbkluYWN0aXZlOiBvbkluYWN0aXZlXG4gICAgLy8gU2VsZWN0aW9uXG4gICAgLFxuICAgIHNlbGVjdGVkS2V5czogbWVyZ2VkU2VsZWN0S2V5c1xuICAgIC8vIExldmVsXG4gICAgLFxuICAgIGlubGluZUluZGVudDogaW5saW5lSW5kZW50XG4gICAgLy8gUG9wdXBcbiAgICAsXG4gICAgc3ViTWVudU9wZW5EZWxheTogc3ViTWVudU9wZW5EZWxheSxcbiAgICBzdWJNZW51Q2xvc2VEZWxheTogc3ViTWVudUNsb3NlRGVsYXksXG4gICAgZm9yY2VTdWJNZW51UmVuZGVyOiBmb3JjZVN1Yk1lbnVSZW5kZXIsXG4gICAgYnVpbHRpblBsYWNlbWVudHM6IGJ1aWx0aW5QbGFjZW1lbnRzLFxuICAgIHRyaWdnZXJTdWJNZW51QWN0aW9uOiB0cmlnZ2VyU3ViTWVudUFjdGlvbixcbiAgICBnZXRQb3B1cENvbnRhaW5lcjogZ2V0UG9wdXBDb250YWluZXJcbiAgICAvLyBJY29uXG4gICAgLFxuICAgIGl0ZW1JY29uOiBpdGVtSWNvbixcbiAgICBleHBhbmRJY29uOiBleHBhbmRJY29uXG4gICAgLy8gRXZlbnRzXG4gICAgLFxuICAgIG9uSXRlbUNsaWNrOiBvbkludGVybmFsQ2xpY2ssXG4gICAgb25PcGVuQ2hhbmdlOiBvbkludGVybmFsT3BlbkNoYW5nZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQYXRoVXNlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcGF0aFVzZXJDb250ZXh0XG4gIH0sIGNvbnRhaW5lciksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgfSxcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGF0aFJlZ2lzdGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZWdpc3RlclBhdGhDb250ZXh0XG4gIH0sIG1lYXN1cmVDaGlsZExpc3QpKSkpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgTWVudTsiLCJpbXBvcnQgTWVudSBmcm9tIFwiLi9NZW51XCI7XG5pbXBvcnQgTWVudUl0ZW0gZnJvbSBcIi4vTWVudUl0ZW1cIjtcbmltcG9ydCBTdWJNZW51IGZyb20gXCIuL1N1Yk1lbnVcIjtcbmltcG9ydCBNZW51SXRlbUdyb3VwIGZyb20gXCIuL01lbnVJdGVtR3JvdXBcIjtcbmltcG9ydCB7IHVzZUZ1bGxQYXRoIH0gZnJvbSBcIi4vY29udGV4dC9QYXRoQ29udGV4dFwiO1xuaW1wb3J0IERpdmlkZXIgZnJvbSBcIi4vRGl2aWRlclwiO1xuZXhwb3J0IHsgU3ViTWVudSwgTWVudUl0ZW0gYXMgSXRlbSwgTWVudUl0ZW0sIE1lbnVJdGVtR3JvdXAsIE1lbnVJdGVtR3JvdXAgYXMgSXRlbUdyb3VwLCBEaXZpZGVyLCAvKiogQHByaXZhdGUgT25seSB1c2VkIGZvciBhbnRkIGludGVybmFsLiBEbyBub3QgdXNlIGluIHlvdXIgcHJvZHVjdGlvbi4gKi9cbnVzZUZ1bGxQYXRoIH07XG52YXIgRXhwb3J0TWVudSA9IE1lbnU7XG5FeHBvcnRNZW51Lkl0ZW0gPSBNZW51SXRlbTtcbkV4cG9ydE1lbnUuU3ViTWVudSA9IFN1Yk1lbnU7XG5FeHBvcnRNZW51Lkl0ZW1Hcm91cCA9IE1lbnVJdGVtR3JvdXA7XG5FeHBvcnRNZW51LkRpdmlkZXIgPSBEaXZpZGVyO1xuZXhwb3J0IGRlZmF1bHQgRXhwb3J0TWVudTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=
//# sourceURL=webpack-internal:///72512
`)}}]);
